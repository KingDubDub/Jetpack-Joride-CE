; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\JETPACK_JOYRIDE.C"
	.assume ADL=1
	SEGMENT DATA
_ctx:
	DW	0
	DB	0
	DW	13
	DB	0
	DW	26
	DB	0
	DW	39
	DB	0
	DW	52
	DB	0
	DW	65
	DB	0
	DW	78
	DB	0
	DW	91
	DB	0
	DW	104
	DB	0
	DW	0
	DB	0
	DW	13
	DB	0
	DW	26
	DB	0
	DW	39
	DB	0
	DW	52
	DB	0
	DW	65
	DB	0
	DW	78
	DB	0
	DW	91
	DB	0
	DW	104
	DB	0
	DW	0
	DB	0
	DW	13
	DB	0
	DW	26
	DB	0
	DW	39
	DB	0
	DW	52
	DB	0
	DW	65
	DB	0
	DW	78
	DB	0
	DW	91
	DB	0
	DW	104
	DB	0
	DW	0
	DB	0
	DW	26
	DB	0
	DW	52
	DB	0
	DW	65
	DB	0
	DW	0
	DB	0
	DW	26
	DB	0
	DW	52
	DB	0
	DW	78
	DB	0
	DW	0
	DB	0
	DW	13
	DB	0
	DW	26
	DB	0
	DW	52
	DB	0
	DW	65
	DB	0
	DW	0
	DB	0
	DW	26
	DB	0
	DW	52
	DB	0
	DW	78
	DB	0
	DW	0
	DB	0
	DW	26
	DB	0
	DW	52
	DB	0
	DW	65
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	13
	DB	0
	DW	75
	DB	0
	DW	88
	DB	0
	DW	153
	DB	0
	DW	166
	DB	0
	DW	0
	DB	0
	DW	13
	DB	0
	DW	39
	DB	0
	DW	52
	DB	0
	DW	75
	DB	0
	DW	88
	DB	0
	DW	114
	DB	0
	DW	127
	DB	0
	DW	153
	DB	0
	DW	166
	DB	0
	DW	192
	DB	0
	DW	205
	DB	0
	DW	39
	DB	0
	DW	52
	DB	0
	DW	114
	DB	0
	DW	127
	DB	0
	DW	192
	DB	0
	DW	205
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	91
	DB	0
	DW	91
	DB	0
	DW	104
	DB	0
	DW	0
	DB	0
	DW	13
	DB	0
	DW	26
	DB	0
	DW	39
	DB	0
	DW	52
	DB	0
	DW	65
	DB	0
	DW	78
	DB	0
	DW	91
	DB	0
	DW	104
	DB	0
	DW	117
	DB	0
	DW	0
	DB	0
	DW	13
	DB	0
	DW	26
	DB	0
	DW	39
	DB	0
	DW	52
	DB	0
	DW	65
	DB	0
	DW	78
	DB	0
	DW	91
	DB	0
	DW	104
	DB	0
	DW	117
	DB	0
	DW	91
	DB	0
	DW	104
	DB	0
	DW	91
	DB	0
	DW	2000
	DB	0
	DW	26
	DB	0
	DW	13
	DB	0
	DW	26
	DB	0
	DW	39
	DB	0
	DW	52
	DB	0
	DW	0
	DB	0
	DW	26
	DB	0
	DW	13
	DB	0
	DW	26
	DB	0
	DW	39
	DB	0
	DW	26
	DB	0
	DW	52
	DB	0
	DW	0
	DB	0
	DW	13
	DB	0
	DW	26
	DB	0
	DW	39
	DB	0
	DW	26
	DB	0
	DW	2000
	DB	0
	DW	2000
	DB	0
	DW	2000
	DB	0
	DW	2000
	DB	0
	DW	2000
	DB	0
	DW	2000
	DB	0
	DW	2000
	DB	0
	DW	2000
	DB	0
	DW	2000
	DB	0
	DW	2000
	DB	0
_cty:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	0
	DB	0
	DB	0
	DB	0
	DB	13
	DB	13
	DB	13
	DB	13
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	39
	DB	39
	DB	39
	DB	39
	DB	52
	DB	52
	DB	52
	DB	52
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	13
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	0
	DB	0
	DB	0
	DB	0
	DB	13
	DB	13
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	26
	DB	39
	DB	39
	DB	39
	DB	39
	DB	39
	DB	39
	DB	39
	DB	39
	DB	39
	DB	39
	DB	52
	DB	52
	DB	65
	DB	0
	DB	0
	DB	13
	DB	13
	DB	13
	DB	13
	DB	26
	DB	26
	DB	39
	DB	39
	DB	39
	DB	52
	DB	52
	DB	65
	DB	65
	DB	65
	DB	65
	DB	78
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	SEGMENT BSS
_zappBuffer_data:
	DS	326
	SEGMENT DATA
_zappBuffer:
	DW24	_zappBuffer_data
	SEGMENT BSS
_electricBuffer_data:
	DS	1026
	SEGMENT DATA
_electricBuffer:
	DW24	_electricBuffer_data
	SEGMENT BSS
_i:
	DS	1
_i_the_sequal:
	DS	1
_avatarX:
	DS	2*1
_avatarY:
	DS	1
_avatar:
	DS	12
	SEGMENT DATA
_avatarAnimate:
	DB	1
_displacement:
	DB	3
	SEGMENT BSS
_exhaust:
	DS	12
_flightTime:
	DS	1
_frameTime:
	DS	1
_holdTime:
	DS	1
	SEGMENT DATA
_scrollSpeed:
	DB	5
	SEGMENT BSS
_backgroundScroll:
	DS	3
_health:
	DS	1
_monies:
	DS	4*1
_distance:
	DS	4*1
_randVar:
	DS	1
_randVar1:
	DS	1
_zapperY:
	DS	3
_zapperX:
	DS	2
_zapperLength:
	DS	1
_zapperAnimate:
	DS	1
_zapper:
	DS	9
_electric:
	DS	6
_coinX:
	DS	81
_coinY:
	DS	27
_coinAnimate:
	DS	27
_coin:
	DS	12
;    1	#include <stdbool.h>
;    2	#include <stddef.h>
;    3	#include <stdint.h>
;    4	#include <tice.h>
;    5	
;    6	#include <math.h>
;    7	#include <stdio.h>
;    8	#include <stdlib.h>
;    9	#include <string.h>
;   10	
;   11	#include <compression.h>
;   12	#include <graphx.h>
;   13	#include <keypadc.h>
;   14	
;   15	#include "sprites/gfx.h"
;   16	#include "coinShapes.h"
;   17	
;   18	//maximum coins that can spawn, 27 is the maximum safe value currently:
;   19	#define extern MaxCoins 27
;   20	
;   21	//max number of zappers:
;   22	#define MaxZappers 1
;   23	
;   24	//buffer for copying and rotating zappers:
;   25	gfx_UninitedSprite(zappBuffer, 18, 18);
;   26	gfx_UninitedSprite(electricBuffer, 32, 32);
;   27	
;   28	//the most overused variable ever:
;   29	uint8_t i;
;   30	
;   31	//just got a remake:
;   32	uint8_t i_the_sequal;
;   33	
;   34	//the Jetpack Joyride guy's name is Barry Steakfries, which is what I would name
;   35	//my child if I had the desire to marry and have children.
;   36	uint16_t avatarX;
;   37	uint8_t avatarY;
;   38	
;   39	//avatar's sprite array and values for keeping track of animation frames:
;   40	gfx_sprite_t *avatar[4];
;   41	int8_t avatarAnimate = 1;
;   42	int8_t displacement = 3;
;   43	
;   44	//exhaust/flame sprite array for jetpack flight animations:
;   45	gfx_sprite_t *exhaust[4];
;   46	
;   47	//variable used for calculating fire animations:
;   48	uint8_t flightTime;
;   49	
;   50	//time it takes to complete the game loop, used to control the FPS; if it overflows
;   51	//then we have real problems:
;   52	uint8_t frameTime;
;   53	
;   54	//variables for when jetpack is on or not for math calculations:
;   55	int8_t holdTime;
;   56	
;   57	//speed of scrolling for avatar, obstacles, map, etc.
;   58	uint8_t scrollSpeed = 5;
;   59	
;   60	//used for a bad background scroll function that is actually the best for this scenario:
;   61	int24_t backgroundScroll;
;   62	
;   63	//stores if Barry done got wasted or not:
;   64	uint8_t health;
;   65	
;   66	//max monies at $4,294,967,295:
;   67	uint32_t monies;
;   68	
;   69	uint32_t distance;
;   70	
;   71	//for randomization values that need to be reused:
;   72	uint8_t randVar;
;   73	uint8_t randVar1;
;   74	
;   75	//arrays for zapper coordinates:
;   76	uint24_t zapperY[MaxZappers];
;   77	uint16_t zapperX[MaxZappers];
;   78	//measured in beam units, 10x10 pixels:
;   79	uint8_t zapperLength[MaxZappers];
;   80	//zapper animation count, all start at zero:
;   81	uint8_t zapperAnimate[MaxZappers];
;   82	gfx_sprite_t *zapper[3];
;   83	
;   84	//sprite array for electrical flares around zapper nodes:
;   85	gfx_sprite_t *electric[2];
;   86	
;   87	uint24_t coinX[MaxCoins];
;   88	uint8_t coinY[MaxCoins];
;   89	//values for keeping track of coin animation sprites, all start at zero:
;   90	uint8_t coinAnimate[MaxCoins];
;   91	gfx_sprite_t *coin[4];
	SEGMENT CODE
;   92	
;   93	//custom rectangle function: (x and y coords, size x, size y, and color)
;   94	//used for quick-'n-dirty drawing and debug purposes:
;   95	void rect(int16_t x, uint8_t y, int16_t x2, uint8_t y2, uint8_t color)
;   96	{
_rect:
	CALL	__frameset0
;   97	    gfx_SetColor(color);
	LD	C,(IX+18)
	LD	B,0
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;   98	    gfx_FillRectangle(x, y, x2, y2);
	LD	A,(IX+15)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	BC,(IX+12)
	CALL	__stoi
	PUSH	HL
	LD	A,(IX+9)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	BC,(IX+6)
	CALL	__stoi
	PUSH	HL
	CALL	_gfx_FillRectangle
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;   99	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _rect ***************************
;Name                         Addr/Register   Size   Type
;_gfx_FillRectangle                  IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;color                                IX+18      1   parameter
;y2                                   IX+15      1   parameter
;x2                                   IX+12      2   parameter
;y                                     IX+9      1   parameter
;x                                     IX+6      2   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


;  100	
;  101	//sets coin coordinates from coordinate lists:
;  102	void spawnCoin()
;  103	{
_spawnCoin:
	LD	HL,-6
	CALL	__frameset
;  104	    randVar = randInt(30, 160);
	CALL	_random
	LD	BC,131
	CALL	__iremu
	LD	IY,HL
	LEA	HL,IY+30
	LD	A,L
	LD	(_randVar),A
;  105	    randVar1 = randInt(0, 4);
	CALL	_random
	LD	BC,5
	CALL	__iremu
	LD	A,L
	LD	(_randVar1),A
;  106	
;  107	    for(i = 0; i < MaxCoins; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_3
L_1:
;  108	    {
;  109	        coinX[i] = ctx[randVar1][i] + 330;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	A,(_randVar1)
	UEXT	HL
	LD	L,A
	LD	A,81
	CALL	__imul_b
	LD	DE,_ctx
	ADD	HL,DE
	LD	DE,BC
	ADD	HL,DE
	LD	IY,HL
	LD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	(IX+-3),IY	; spill
	LD	(IX+-6),HL	; spill
	LD	IY,(IX+-3)	; unspill
	LD	HL,(IY)
	LD	BC,330
	ADD	HL,BC
	LD	IY,(IX+-6)	; unspill
	LD	(IY),HL
;  110	        coinY[i] = cty[randVar1][i] + randVar;
	LD	A,(_randVar1)
	UEXT	HL
	LD	L,A
	LD	A,27
	CALL	__imul_b
	LD	BC,_cty
	ADD	HL,BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinY
	ADD	HL,BC
	LD	A,(IY)
	LD	BC,(_randVar)
	ADD	A,C
	LD	(HL),A
;  111	        coinAnimate[i] = 0;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinAnimate
	ADD	HL,BC
	LD	(HL),0
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  112	    }
L_3:
	LD	A,(_i)
	CP	A,27
	JR	C,L_1
;  113	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _spawnCoin ***************************
;Name                         Addr/Register   Size   Type
;_coinAnimate                        STATIC     27   variable
;_coinY                              STATIC     27   variable
;_cty                                STATIC    135   variable
;_coinX                              STATIC     81   variable
;_ctx                                STATIC    405   variable
;_i                                  STATIC      1   variable
;_randVar1                           STATIC      1   variable
;_randVar                            STATIC      1   variable
;_random                             IMPORT  -----   function


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  114	
;  115	//randomly generates zapper coordinates:
;  116	void spawnZapper()
;  117	{
_spawnZapper:
;  118	    randVar = randInt(2, 5);
	CALL	_random
	LD	A,L
	AND	A,3
	UEXT	HL
	LD	L,A
	INC	HL
	INC	HL
	LD	A,L
	LD	(_randVar),A
;  119	    randVar1 = randInt(0, 200 - (randVar*10));
	CALL	_random
	LD	A,(_randVar)
	LD	DE,HL
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LD	BC,HL
	LD	HL,200
	OR	A,A
	SBC	HL,BC
	LD	BC,HL
	LD	HL,DE
	INC	BC
	CALL	__iremu
	LD	A,L
	LD	(_randVar1),A
;  120	
;  121	    for(i = 0; i < MaxZappers; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_7
L_5:
;  122	    {
;  123	        zapperX[i] = 330;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	(HL),74
	INC	HL
	LD	(HL),1
;  124	        zapperY[i] = randVar1;
	LD	A,(_randVar1)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	(HL),DE
;  125	        zapperLength[i] = randVar;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	A,(_randVar)
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	(HL),A
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  126	    }
L_7:
	LD	A,(_i)
	CP	A,1
	JR	C,L_5
;  127	}
	RET	


;**************************** _spawnZapper ***************************
;Name                         Addr/Register   Size   Type
;_zapperLength                       STATIC      1   variable
;_zapperY                            STATIC      3   variable
;_zapperX                            STATIC      2   variable
;_i                                  STATIC      1   variable
;_randVar1                           STATIC      1   variable
;_randVar                            STATIC      1   variable
;_random                             IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  128	
;  129	void main(void)
;  130	{
_main:
	LD	HL,-52
	CALL	__frameset
;  131	    //make background sprite variables and a quick decompression slot:
;  132	    gfx_sprite_t *background, *nozzle, *beam, *decompressorVar;
;  133	
;  134	    background = gfx_MallocSprite(192, 240);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,240
	PUSH	BC
	LD	BC,192
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-15),HL
;  135	    zx7_Decompress(background, background_compressed);
	LD	BC,_background_compressed
	PUSH	BC
	LD	BC,(IX+-15)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  136	
;  137	    //jetpack nozzle that glows when releasing exhaust:
;  138	    nozzle = gfx_MallocSprite(nozzle_width, nozzle_height);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-21),HL
;  139	    zx7_Decompress(nozzle, nozzle_compressed);
	LD	BC,_nozzle_compressed
	PUSH	BC
	LD	BC,(IX+-21)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  140	
;  141	    //zapper beam:
;  142	    beam = gfx_MallocSprite(10, 10);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,10
	PUSH	BC
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-18),HL
;  143	    zx7_Decompress(beam, beam_compressed);
	LD	BC,_beam_compressed
	PUSH	BC
	LD	BC,(IX+-18)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  144	
;  145	    //decompressing avatar spritesheet:
;  146	    for(i = 0; i < 4; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_11
L_9:
;  147	    {
;  148	        decompressorVar = gfx_MallocSprite(30, 40);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,30
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  149	        zx7_Decompress(decompressorVar, avatarSheet_tiles_compressed[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_avatarSheet_tiles_compressed
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  150	        avatar[i] = decompressorVar;
	LD	A,(_i)
	UEXT	HL
	LD	BC,(IX+-3)
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_avatar
	ADD	HL,DE
	LD	(HL),BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  151	    }
L_11:
	LD	A,(_i)
	CP	A,4
	JR	C,L_9
;  152	
;  153	    //jetpack exhaust:
;  154	    for(i = 0; i < 3; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_14
L_12:
;  155	    {
;  156	        decompressorVar = gfx_MallocSprite(11, 20);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,20
	PUSH	BC
	LD	BC,11
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  157	        zx7_Decompress(decompressorVar, exhaustSheet_tiles_compressed[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_exhaustSheet_tiles_compressed
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  158	        exhaust[i] = decompressorVar;
	LD	A,(_i)
	UEXT	HL
	LD	BC,(IX+-3)
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_exhaust
	ADD	HL,DE
	LD	(HL),BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  159	    }
L_14:
	LD	A,(_i)
	CP	A,3
	JR	C,L_12
;  160	
;  161	    //decompressing coin spritesheet:
;  162	    for(i = 0; i < 4; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_18
L_16:
;  163	    {
;  164	        decompressorVar = gfx_MallocSprite(10, 10);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,10
	PUSH	BC
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  165	        zx7_Decompress(decompressorVar, coinSheet_tiles_compressed[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_coinSheet_tiles_compressed
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  166	        coin[i] = decompressorVar;
	LD	A,(_i)
	UEXT	HL
	LD	BC,(IX+-3)
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_coin
	ADD	HL,DE
	LD	(HL),BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  167	    }
L_18:
	LD	A,(_i)
	CP	A,4
	JR	C,L_16
;  168	
;  169	    //zappers:
;  170	    for(i = 0; i < 3; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_22
L_20:
;  171	    {
;  172	        decompressorVar = gfx_MallocSprite(18, 18);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,18
	PUSH	BC
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  173	        zx7_Decompress(decompressorVar, zapperSheet_tiles_compressed[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperSheet_tiles_compressed
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  174	        zapper[i] = decompressorVar;
	LD	A,(_i)
	UEXT	HL
	LD	BC,(IX+-3)
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_zapper
	ADD	HL,DE
	LD	(HL),BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  175	    }
L_22:
	LD	A,(_i)
	CP	A,3
	JR	C,L_20
;  176	
;  177	    //zapper lightning:
;  178	    for(i = 0; i < 2; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_26
L_24:
;  179	    {
;  180	        decompressorVar = gfx_MallocSprite(32, 32);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,32
	PUSH	BC
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  181	        zx7_Decompress(decompressorVar, electricSheet_tiles_compressed[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electricSheet_tiles_compressed
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  182	        electric[i] = decompressorVar;
	LD	A,(_i)
	UEXT	HL
	LD	BC,(IX+-3)
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_electric
	ADD	HL,DE
	LD	(HL),BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  183	    }
L_26:
	LD	A,(_i)
	CP	A,2
	JR	C,L_24
;  184	
;  185	    //initialize GFX libraries:
;  186	    gfx_Begin();
	CALL	_gfx_Begin
;  187	    gfx_SetDrawBuffer();
	LD	BC,1
	PUSH	BC
	CALL	_gfx_SetDraw
	POP	BC
;  188	
;  189	    gfx_SetPalette(global_palette, sizeof_global_palette, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,188
	PUSH	BC
	LD	BC,_global_palette
	PUSH	BC
	CALL	_gfx_SetPalette
	POP	BC
	POP	BC
	POP	BC
;  190	    gfx_SetTransparentColor(0);
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTransparentColor
	POP	BC
;  191	
;  192	    //in case colors don't initialize correctly, use black for debugging:
;  193	    gfx_SetColor(1);
	LD	BC,1
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  194	
;  195	    //start up a timer for FPS monitoring, do not move:
;  196	    timer_Control = TIMER1_ENABLE | TIMER1_32K | TIMER1_UP;
	LD	HL,15859760
;  197	
;  198	    //all text printed is gray:
;  199	    gfx_SetTextFGColor(2);
	LD	BC,2
	PUSH	BC
	LD	(HL),3
	INC	HL
	LD	(HL),2
	CALL	_gfx_SetTextFGColor
	POP	BC
;  200	
;  201	    GAMESTART:
L_29:
;  202	    //I just couldn't resist.
;  203	
;  204	    //reset variables for when a game starts:
;  205	    avatarX = 24;
	LD	HL,_avatarX
	LD	(HL),24
	INC	HL
	LD	(HL),0
;  206	    avatarY = 185;
	LD	A,185
	LD	(_avatarY),A
;  207	    health = 1;
	LD	A,1
	LD	(_health),A
;  208	    holdTime, distance, monies = 0;
	LD	BC,0
	LD	(_monies),BC
	XOR	A,A
	LD	(_monies+3),A
;  209	
;  210	    spawnCoin();
	CALL	_spawnCoin
;  211	    spawnZapper();
	CALL	_spawnZapper
;  212	
;  213	    // Loop until clear is pressed:
;  214	    do{
L_101:
;  215	        //update keys, not actually necessary and causes lag but fixes bugs with update errors:
;  216	        kb_Scan();
	CALL	_kb_Scan
;  217	
;  218	        //this is the best way I've found to draw the backgrounds, smaller and faster than a smart system:
;  219	        gfx_Sprite(background, backgroundScroll - 192, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,16777024
	LD	HL,(_backgroundScroll)
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+-15)
	PUSH	BC
	CALL	_gfx_Sprite
	POP	BC
	POP	BC
	POP	BC
;  220	        gfx_Sprite(background, backgroundScroll, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,(_backgroundScroll)
	PUSH	BC
	LD	BC,(IX+-15)
	PUSH	BC
	CALL	_gfx_Sprite
	POP	BC
	POP	BC
	POP	BC
;  221	        gfx_Sprite(background, backgroundScroll + 192, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,192
	LD	HL,(_backgroundScroll)
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+-15)
	PUSH	BC
	CALL	_gfx_Sprite
	POP	BC
	POP	BC
	POP	BC
;  222	
;  223	        if ((backgroundScroll - scrollSpeed) <= 0)
	LD	A,(_scrollSpeed)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(_backgroundScroll)
	OR	A,A
	SBC	HL,BC
	LD	(IX+-36),HL
	LD	BC,HL
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_31
;  224	        {
;  225	            backgroundScroll += (192 - scrollSpeed);
	LD	A,(_scrollSpeed)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,192
	OR	A,A
	SBC	HL,BC
	LD	BC,(_backgroundScroll)
	ADD	HL,BC
	LD	(_backgroundScroll),HL
;  226	        } else {
	JR	L_48
L_31:
;  227	            backgroundScroll -= scrollSpeed;
	LD	BC,(IX+-36)
	LD	(_backgroundScroll),BC
;  228	        }
L_48:
;  229	
;  230	
;  231	        //run controls until Barry gets wasted, then bounces his corpse around:
;  232	        if (health > 0)
	XOR	A,A
	LD	HL,_health
	CP	A,(HL)
	JR	NC,L_50
;  233	        {
;  234	            if (kb_Data[1] & kb_2nd)
	LD	A,(16056338)
	AND	A,32
	JR	Z,L_40
;  235	            {
;  236	                if((avatarY > 20) && (holdTime < 12))
	LD	A,20
	LD	HL,_avatarY
	CP	A,(HL)
	JR	NC,L_35
	LD	A,(_holdTime)
	CP	A,12
	JP	P,L_35
;  237	                {
;  238	                    holdTime += 1;
	LD	A,(_holdTime)
	INC	A
	LD	(_holdTime),A
;  239	                }
L_35:
;  240	
;  241	                if (flightTime < 11)
	LD	A,(_flightTime)
	CP	A,11
	JR	NC,L_41
;  242	                {
;  243	                    ++flightTime;
	LD	A,(_flightTime)
	INC	A
	LD	(_flightTime),A
;  244	                }
;  245	
;  246	            } else {
	JR	L_41
L_40:
;  247	
;  248	                if((avatarY < (185)) && (holdTime > -10))
	LD	A,(_avatarY)
	CP	A,185
	JR	NC,L_38
	LD	A,246
	LD	HL,_holdTime
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_38
;  249	                {
;  250	                    holdTime -= 1;
	LD	A,(_holdTime)
	DEC	A
	LD	(_holdTime),A
;  251	                }
L_38:
;  252	
;  253	                flightTime = 0;
	XOR	A,A
	LD	(_flightTime),A
;  254	            }
L_41:
;  255	
;  256	            //SAX got pretty mad about this part, turns out a linear equation can model a curve and
;  257	            //is actually better than a cubic function:
;  258	            avatarY -= (holdTime);
	LD	BC,(_holdTime)
	LD	A,(_avatarY)
	SUB	A,C
	LD	(_avatarY),A
;  259	
;  260	            //sees if Y-value rolled past zero or 198, figures out if it was going up
;  261	            //or down, and auto-corrects accordingly:
;  262	            if ((avatarY > (186)) || (avatarY < 20))
	LD	A,186
	LD	HL,_avatarY
	CP	A,(HL)
	JR	C,L_46
	LD	A,(_avatarY)
	CP	A,20
	JR	NC,L_50
L_46:
;  263	            {
;  264	                if (holdTime > 0)
	XOR	A,A
	LD	HL,_holdTime
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_44
;  265	                {
;  266	                    avatarY = 20;
	LD	A,20
	LD	(_avatarY),A
;  267	                } else {
	JR	L_45
L_44:
;  268	                    avatarY = 185;
	LD	A,185
	LD	(_avatarY),A
;  269	                }
L_45:
;  270	                holdTime = 0;
	XOR	A,A
	LD	(_holdTime),A
;  271	            }
;  272	        }
L_50:
;  273	
;  274	        //make some coins with no regard for if they exist or not:
;  275	        if (randInt(0,200) == 0){spawnCoin();}
	CALL	_random
	LD	BC,201
	CALL	__iremu
	CALL	__icmpzero
	JR	NZ,L_64
	CALL	_spawnCoin
L_64:
;  276	
;  277	        //bit that runs coin collision and movement:
;  278	        for(i = 0; i < MaxCoins; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_63
L_61:
;  279	        {
;  280	            if (coinX[i] < 1000)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	(IX+-6),HL
	OR	A,A
	LD	HL,(HL)
	LD	BC,1000
	SBC	HL,BC
	JR	NC,L_62
;  281	            {
;  282	                //collision detection:
;  283	                if (gfx_CheckRectangleHotspot(avatarX,avatarY,24,40,coinX[i]-9,coinY[i]+1,8,8))
	LD	BC,(IX+-6)
	LD	(IX+-27),BC
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+24
	OR	A,A
	LD	HL,(IX+-6)
	LD	IY,(HL)
	LEA	HL,IY+-9
	SBC	HL,BC
	JR	NC,L_58
	LD	BC,(IX+-6)
	LD	(IX+-27),BC
	LD	HL,(IX+-6)
	LD	DE,(HL)
	DEC	DE
	LD	BC,(_avatarX)
	CALL	__stoiu
	OR	A,A
	SBC	HL,DE
	JR	NC,L_58
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinY
	ADD	HL,BC
	LD	(IX+-39),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	INC	BC
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	DE,IY+40
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	CALL	__setflag
	JP	P,L_58
	LD	HL,(IX+-39)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	OR	A,A
	LEA	BC,IY+9
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_58
;  284	                {
;  285	                    coinX[i] = 1020;
	LD	BC,(IX+-6)
	LD	(IX+-27),BC
	LD	HL,(IX+-6)
	LD	BC,1020
	LD	(HL),BC
;  286	                    ++monies;
	LD	A,(_monies+3)
	LD	E,A
	LD	A,1
	LD	HL,(_monies)
	CALL	__ladd_b
	LD	(_monies),HL
	LD	A,E
	LD	(_monies+3),A
;  287	                }
L_58:
;  288	
;  289	                //draw coin when on screen and update animations:
;  290	                if (coinX[i] < 330) {
	LD	BC,(IX+-27)
	LD	(IX+-30),BC
	LD	HL,BC
	LD	HL,(HL)
	LD	BC,330
	OR	A,A
	SBC	HL,BC
	JR	NC,L_59
;  291	
;  292	                    gfx_TransparentSprite(coin[(coinAnimate[i]/10)], (coinX[i]-10), coinY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinAnimate
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+-30)
	LD	IY,(IY)
	ADD	HL,BC
	LD	BC,_coin
	ADD	HL,BC
	LEA	BC,IY+-10
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  293	
;  294	                    if (coinAnimate[i] < 38)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinAnimate
	ADD	HL,BC
	LD	(IX+-12),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,38
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_56
;  295	                    {
;  296	                        coinAnimate[i] += 2;
	LD	HL,(IX+-12)
	LD	A,(HL)
	INC	A
	INC	A
	LD	HL,(IX+-12)
	LD	(HL),A
;  297	                    } else {
	JR	L_59
L_56:
;  298	                        coinAnimate[i] = 0;
	LD	HL,(IX+-12)
	LD	(HL),0
;  299	                    }
;  300	                }
L_59:
;  301	
;  302	                coinX[i] -= scrollSpeed;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	(IX+-42),HL
	LD	A,(_scrollSpeed)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-42)
	LD	HL,(HL)
	LD	IY,(IX+-42)
	OR	A,A
	SBC	HL,BC
	LD	(IY),HL
;  303	            }
;  304	        }
L_62:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_63:
	LD	A,(_i)
	CP	A,27
	JR	C,L_61
;  305	
;  306	        //make a zapper just like we make coins, very VERY badly:
;  307	        if(randInt(0,100) == 0){spawnZapper();}
	CALL	_random
	LD	BC,101
	CALL	__iremu
	CALL	__icmpzero
	JR	NZ,L_86
	CALL	_spawnZapper
L_86:
;  308	
;  309	        //bit that calculates obstacles and zappers and stuff:
;  310	        for (i=0; i < MaxZappers; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_85
L_83:
;  311	        {
;  312	            //drawing the zapper beams:
;  313	            if (zapperX[i] < 1000)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,1000
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_84
;  314	            {
;  315	                for (i_the_sequal=0;i_the_sequal < zapperLength[i];++i_the_sequal)
	XOR	A,A
	LD	(_i_the_sequal),A
	JR	L_69
L_67:
;  316	                {
;  317	                    gfx_TransparentSprite(beam, zapperX[i]-14, zapperY[i]+16+(i_the_sequal*10));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_i_the_sequal)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LEA	BC,IY+16
	ADD	HL,BC
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+-14
	PUSH	BC
	LD	BC,(IX+-18)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
	LD	A,(_i_the_sequal)
	INC	A
	LD	(_i_the_sequal),A
;  318	                }
L_69:
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(_i_the_sequal)
	CP	A,(HL)
	JR	C,L_67
;  319	
;  320	                //draw zapper pairs with distance of zapperLength between them:
;  321	                if (zapperX[i] < 336)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,336
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_77
;  322	                {
;  323	                    randVar = randInt(0,1);
	CALL	_random
	LD	A,L
	AND	A,1
	LD	(_randVar),A
;  324	
;  325	                    if (randInt(0,1) == 1)
	CALL	_random
	LD	A,L
	AND	A,1
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,1
	SBC	HL,BC
	JR	NZ,L_71
;  326	                    {
;  327	                        gfx_TransparentSprite(gfx_FlipSpriteX(electric[randVar], electricBuffer), zapperX[i]-25, zapperY[i]-7);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LEA	BC,IY+-7
	PUSH	BC
	LD	IY,HL
	LD	A,(_randVar)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LEA	BC,IY+-25
	PUSH	BC
	LD	BC,_electric
	ADD	HL,BC
	LD	BC,(_electricBuffer)
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteX
	POP	BC
	POP	BC
	PUSH	HL
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  328	                        gfx_TransparentSprite(gfx_FlipSpriteY(electric[randVar], electricBuffer), zapperX[i]-25,  zapperY[i]+7+(zapperLength[i]*10));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LEA	BC,IY+7
	ADD	HL,BC
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LD	A,(_randVar)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LEA	BC,IY+-25
	PUSH	BC
	LD	BC,_electric
	ADD	HL,BC
	LD	BC,(_electricBuffer)
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteY
	POP	BC
	POP	BC
	PUSH	HL
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  329	                    } else {
	JR	L_72
L_71:
;  330	                        gfx_TransparentSprite(gfx_RotateSpriteHalf(electric[randVar], electricBuffer), zapperX[i]-25, zapperY[i]-7);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LEA	BC,IY+-7
	PUSH	BC
	LD	IY,HL
	LD	A,(_randVar)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LEA	BC,IY+-25
	PUSH	BC
	LD	BC,_electric
	ADD	HL,BC
	LD	BC,(_electricBuffer)
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_RotateSpriteHalf
	POP	BC
	POP	BC
	PUSH	HL
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  331	                        gfx_TransparentSprite(electric[randVar], zapperX[i]-25,  zapperY[i]+7+(zapperLength[i]*10));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LEA	BC,IY+7
	ADD	HL,BC
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LD	A,(_randVar)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric
	ADD	HL,BC
	LEA	BC,IY+-25
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  332	                    }
L_72:
;  333	
;  334	                    gfx_TransparentSprite(gfx_FlipSpriteX(zapper[zapperAnimate[i]/10], zappBuffer), zapperX[i]-18, zapperY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperAnimate
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LEA	BC,IY+-18
	PUSH	BC
	LD	BC,_zapper
	ADD	HL,BC
	LD	BC,(_zappBuffer)
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteX
	POP	BC
	POP	BC
	PUSH	HL
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  335	                    gfx_TransparentSprite(zapper[zapperAnimate[i]/10], zapperX[i]-18, zapperY[i]+14+(zapperLength[i]*10));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LEA	BC,IY+14
	ADD	HL,BC
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperAnimate
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapper
	ADD	HL,BC
	LEA	BC,IY+-18
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  336	
;  337	                    if (zapperAnimate[i] < 28)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperAnimate
	ADD	HL,BC
	LD	(IX+-9),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,28
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_74
;  338	                    {
;  339	                        zapperAnimate[i] += 2;
	LD	HL,(IX+-9)
	LD	A,(HL)
	INC	A
	INC	A
	LD	HL,(IX+-9)
	LD	(HL),A
;  340	                    } else {
	JR	L_77
L_74:
;  341	                        zapperAnimate[i] = 0;
	LD	HL,(IX+-9)
	LD	(HL),0
;  342	                    }
;  343	                }
L_77:
;  344	
;  345	                zapperX[i] -= scrollSpeed;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	(IX+-24),HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	(IX+-45),HL
	LD	A,(_scrollSpeed)
	LD	C,A
	LD	HL,(IX+-45)
	LD	HL,(HL)
	LD	B,0
	OR	A,A
	SBC.SIS	HL,BC
	LD	BC,HL
	LD	HL,(IX+-45)
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  346	
;  347	                //collision between to zappers:
;  348	                if (gfx_CheckRectangleHotspot(avatarX, zapperY[i]+2, 30, (zapperLength[i]*10)+30, zapperX[i]-14, avatarY, 10, 50))
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,(IX+-45)
	LD	BC,(IY)
	LD	IY,HL
	LEA	DE,IY+30
	CALL	__stoiu
	LD	IY,HL
	LEA	HL,IY+-14
	OR	A,A
	SBC	HL,DE
	CALL	__setflag
	JP	P,L_84
	LD	BC,_zapperX
	LD	HL,(IX+-24)
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	DE,HL
	DEC	DE
	DEC	DE
	DEC	DE
	DEC	DE
	LD	BC,(_avatarX)
	CALL	__stoiu
	OR	A,A
	SBC	HL,DE
	CALL	__setflag
	JP	P,L_84
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LEA	BC,IY+2
	LD	(IX+-33),BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LD	IY,HL
	LEA	HL,IY+30
	LD	BC,(IX+-33)
	ADD	HL,BC
	LD	BC,HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	OR	A,A
	SBC	HL,BC
	JR	NC,L_84
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+50
	LD	HL,(IX+-33)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_84
;  349	                {
;  350	                    --health;
	LD	A,(_health)
	DEC	A
	LD	(_health),A
;  351	                }
;  352	            }
;  353	        }
L_84:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_85:
	LD	A,(_i)
	CP	A,1
	JR	C,L_83
;  354	
;  355	        //draws the avatar after a few hundred lines of code:
;  356	        gfx_TransparentSprite_NoClip(avatar[displacement/3], avatarX, avatarY-abs((displacement/3)-1));
	LD	A,(_displacement)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,3
	CALL	__idivs
	DEC	HL
	PUSH	HL
	CALL	_abs
	POP	BC
	LD	A,(_avatarY)
	SUB	A,L
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,(_avatarX)
	LD	A,(_displacement)
	LD	D,A
	CALL	__stoiu
	PUSH	HL
	SEXT	HL
	LD	L,D
	LD	BC,3
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_avatar
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
;  357	
;  358	        //bit that runs avatar animations:
;  359	        if (avatarY < 185)
	LD	A,(_avatarY)
	CP	A,185
	JR	NC,L_94
;  360	        {
;  361	            displacement = 9;
	LD	A,9
	LD	(_displacement),A
;  362	        } else {
	JR	L_96
L_94:
;  363	
;  364	            if (displacement == 9)
	LD	A,(_displacement)
	CP	A,9
	JR	NZ,L_91
;  365	            {
;  366	                displacement = 3;
	LD	A,3
	LD	(_displacement),A
;  367	            }
L_91:
;  368	
;  369	            if((displacement < 1) || (displacement > 7))
	LD	A,(_displacement)
	CP	A,1
	CALL	__setflag
	JP	M,L_90
	LD	A,7
	LD	HL,_displacement
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_92
L_90:
;  370	            {
;  371	                avatarAnimate *= -1;
	LD	A,(_avatarAnimate)
	NEG	
	LD	(_avatarAnimate),A
;  372	            }
L_92:
;  373	
;  374	            displacement += avatarAnimate;
	LD	BC,(_avatarAnimate)
	LD	A,(_displacement)
	ADD	A,C
	LD	(_displacement),A
;  375	        }
L_96:
;  376	
;  377	        //bit that draws exhaust when in flight:
;  378	        if (kb_Data[1] & kb_2nd)
	LD	A,(16056338)
	AND	A,32
	JR	Z,L_97
;  379	        {
;  380	            gfx_TransparentSprite_NoClip(exhaust[flightTime/4], avatarX+randInt(1,3), avatarY+31);
	LD	A,(_avatarY)
	ADD	A,31
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_random
	LD	BC,3
	CALL	__iremu
	LD	DE,HL
	INC	DE
	LD	BC,(_avatarX)
	CALL	__stoiu
	ADD	HL,DE
	PUSH	HL
	LD	A,(_flightTime)
	UEXT	HL
	LD	L,A
	LD	BC,4
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_exhaust
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
;  381	            gfx_TransparentSprite_NoClip(nozzle, avatarX+4, avatarY+31);
	LD	A,(_avatarY)
	ADD	A,31
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+4
	PUSH	BC
	LD	BC,(IX+-21)
	PUSH	BC
	CALL	_gfx_TransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
;  382	        }
L_97:
;  383	
;  384	        //FPS counter:
;  385	        frameTime = (32768 / timer_1_Counter);
	LD	HL,32768
	LD	E,0
	LD	BC,(15859712)
	LD	A,(15859715)
	CALL	__ldivu
	LD	BC,HL
	LD	A,C
	LD	(_frameTime),A
;  386	
;  387	        if (frameTime > 25)
	LD	A,25
	LD	HL,_frameTime
	CP	A,(HL)
	JR	NC,L_99
;  388	        {
;  389	            delay(40 - (1000/frameTime));
	LD	A,(_frameTime)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,1000
	CALL	__idivs
	LD	BC,HL
	LD.LIS	HL,40
	OR	A,A
	SBC.SIS	HL,BC
	PUSH	HL
	CALL	_delay
	POP	BC
;  390	        }
L_99:
;  391	
;  392	        timer_1_Counter = 0;
;  393	
;  394	        gfx_SetTextScale(1, 1);
	LD	BC,1
	PUSH	BC
	PUSH	BC
	LD	BC,0
	LD	(15859712),BC
	XOR	A,A
	LD	(15859715),A
	CALL	_gfx_SetTextScale
	POP	BC
	POP	BC
;  395	        gfx_SetTextXY(280, 10);
	LD	BC,10
	PUSH	BC
	LD	BC,280
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  396	        gfx_PrintInt(frameTime, 2);
	LD	A,(_frameTime)
	UEXT	HL
	LD	BC,2
	PUSH	BC
	LD	L,A
	PUSH	HL
	LD	(IX+-52),A
	CALL	_gfx_PrintInt
	LD	A,(IX+-52)
	POP	BC
	POP	BC
;  397	
;  398	        gfx_SetTextXY(10, 30);
	LD	BC,30
	PUSH	BC
	LD	BC,10
	PUSH	BC
	LD	(IX+-52),A
	CALL	_gfx_SetTextXY
	LD	A,(IX+-52)
	POP	BC
	POP	BC
;  399	        gfx_PrintInt(monies, 4);
	LD	BC,4
	PUSH	BC
	LD	BC,(_monies)
	PUSH	BC
	LD	(IX+-52),A
	CALL	_gfx_PrintInt
	LD	A,(IX+-52)
	POP	BC
	POP	BC
;  400	
;  401	        gfx_SetTextScale(2,2);
	LD	BC,2
	PUSH	BC
	PUSH	BC
	LD	(IX+-52),A
	CALL	_gfx_SetTextScale
	LD	A,(IX+-52)
	POP	BC
	POP	BC
;  402	        gfx_SetTextXY(10, 10);
	LD	BC,10
	PUSH	BC
	PUSH	BC
	LD	(IX+-52),A
	CALL	_gfx_SetTextXY
	LD	A,(IX+-52)
	POP	BC
	POP	BC
;  403	        gfx_PrintInt((distance += scrollSpeed)/15, 4);
	UEXT	HL
	LD	A,(_scrollSpeed)
	LD	L,A
	LD	A,(_distance+3)
	LD	E,A
	LD	BC,HL
	LD	A,H
	LD	HL,(_distance)
	CALL	__ladd
	LD	(_distance),HL
	LD	A,E
	LD	(_distance+3),A
	LD	E,A
	XOR	A,A
	LD	BC,15
	LD	(IX+-48),HL	; spill
	LD	HL,4
	LD	(IX+-51),HL	; spill
	LD	HL,(IX+-48)	; unspill
	LD	(IX+-48),HL	; spill
	LD	HL,(IX+-51)	; unspill
	PUSH	HL
	LD	HL,(IX+-48)	; unspill
	CALL	__ldivu
	PUSH	HL
	CALL	_gfx_PrintInt
	POP	BC
	POP	BC
;  404	
;  405	        //gfx_BlitBuffer();
;  406	        gfx_SwapDraw();
	CALL	_gfx_SwapDraw
;  407	
;  408	    } while (!(kb_Data[6] & kb_Clear) && (health > 0));
	LD	A,(16056348)
	AND	A,64
	JR	NZ,L_111
	XOR	A,A
	LD	HL,_health
	CP	A,(HL)
	JR	C,L_101
L_111:
;  409	
;  410	    if (health < 1)
	LD	A,(_health)
	CP	A,1
	JR	NC,L_112
;  411	    {
;  412	        rect(0,0,320,240,1);
	LD	BC,1
	PUSH	BC
	LD	BC,240
	PUSH	BC
	LD	BC,320
	PUSH	BC
	LD	BC,0
	PUSH	BC
	PUSH	BC
	CALL	_rect
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  413	        gfx_SetTextScale(4, 4);
	LD	BC,4
	PUSH	BC
	PUSH	BC
	CALL	_gfx_SetTextScale
	POP	BC
	POP	BC
;  414	        gfx_PrintStringXY("U is ded lol.", 15, 100);
	LD	BC,100
	PUSH	BC
	LD	BC,15
	PUSH	BC
	LD	BC,L__50
	PUSH	BC
	CALL	_gfx_PrintStringXY
	POP	BC
	POP	BC
	POP	BC
;  415	        gfx_SwapDraw();
	CALL	_gfx_SwapDraw
;  416	
;  417	        while (os_GetCSC());
L_104:
	CALL	_os_GetCSC
	OR	A,A
	JR	NZ,L_104
;  418	        while (!os_GetCSC());
L_106:
	CALL	_os_GetCSC
	OR	A,A
	JR	Z,L_106
;  419	
;  420	        if (kb_Data[6] != kb_Clear)
	LD	A,(16056348)
	CP	A,64
	JR	NZ,L_29
;  421	        {
;  422	            goto GAMESTART;
;  423	        }
;  424	    }
L_112:
;  425	
;  426	    //erase the decompressed sprites, very important:
;  427	    free(background);
	LD	BC,(IX+-15)
	PUSH	BC
	CALL	_free
	POP	BC
;  428	    free(nozzle);
	LD	BC,(IX+-21)
	PUSH	BC
	CALL	_free
	POP	BC
;  429	    free(beam);
	LD	BC,(IX+-18)
	PUSH	BC
	CALL	_free
	POP	BC
;  430	    free(decompressorVar);
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free
	POP	BC
;  431	
;  432	    //stop libraries, not doing so causes "interesting" results
;  433	    gfx_End();
	CALL	_gfx_End
;  434	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_gfx_End                            IMPORT  -----   function
;_free                               IMPORT  -----   function
;_os_GetCSC                          IMPORT  -----   function
;_gfx_PrintStringXY                  IMPORT  -----   function
;_gfx_SwapDraw                       IMPORT  -----   function
;_distance                           STATIC      4   variable
;_gfx_PrintInt                       IMPORT  -----   function
;_gfx_SetTextXY                      IMPORT  -----   function
;_gfx_SetTextScale                   IMPORT  -----   function
;_delay                              IMPORT  -----   function
;_frameTime                          STATIC      1   variable
;_avatarAnimate                      STATIC      1   variable
;_displacement                       STATIC      1   variable
;_abs                                IMPORT  -----   function
;_gfx_TransparentSprite_NoClip       IMPORT  -----   function
;_zapperAnimate                      STATIC      1   variable
;_zappBuffer                         STATIC      3   variable
;_gfx_RotateSpriteHalf               IMPORT  -----   function
;_gfx_FlipSpriteY                    IMPORT  -----   function
;_electricBuffer                     STATIC      3   variable
;_gfx_FlipSpriteX                    IMPORT  -----   function
;_randVar                            STATIC      1   variable
;_zapperLength                       STATIC      1   variable
;_zapperY                            STATIC      3   variable
;_i_the_sequal                       STATIC      1   variable
;_zapperX                            STATIC      2   variable
;_coinAnimate                        STATIC     27   variable
;_gfx_TransparentSprite              IMPORT  -----   function
;_coinY                              STATIC     27   variable
;_coinX                              STATIC     81   variable
;_random                             IMPORT  -----   function
;_flightTime                         STATIC      1   variable
;_holdTime                           STATIC      1   variable
;_scrollSpeed                        STATIC      1   variable
;_backgroundScroll                   STATIC      3   variable
;_gfx_Sprite                         IMPORT  -----   function
;_kb_Scan                            IMPORT  -----   function
;_monies                             STATIC      4   variable
;_health                             STATIC      1   variable
;_avatarY                            STATIC      1   variable
;_avatarX                            STATIC      2   variable
;_gfx_SetTextFGColor                 IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_gfx_SetTransparentColor            IMPORT  -----   function
;_global_palette                     IMPORT    188   variable
;_gfx_SetPalette                     IMPORT  -----   function
;_gfx_SetDraw                        IMPORT  -----   function
;_gfx_Begin                          IMPORT  -----   function
;_electric                           STATIC      6   variable
;_electricSheet_tiles_compressed      IMPORT      6   variable
;_zapper                             STATIC      9   variable
;_zapperSheet_tiles_compressed       IMPORT      9   variable
;_coin                               STATIC     12   variable
;_coinSheet_tiles_compressed         IMPORT     12   variable
;_exhaust                            STATIC     12   variable
;_exhaustSheet_tiles_compressed      IMPORT     12   variable
;_avatar                             STATIC     12   variable
;_avatarSheet_tiles_compressed       IMPORT     12   variable
;_i                                  STATIC      1   variable
;_beam_compressed                    IMPORT     14   variable
;_nozzle_compressed                  IMPORT     15   variable
;_background_compressed              IMPORT    670   variable
;_zx7_Decompress                     IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;_gfx_AllocSprite                    IMPORT  -----   function
;G_3                                  IX-39      3   variable
;G_0                                  IX-36      3   variable
;G_12                                 IX-33      3   variable
;G_6                                  IX-30      3   variable
;G_5                                  IX-27      3   variable
;G_11                                 IX-24      3   variable
;nozzle                               IX-21      3   variable
;beam                                 IX-18      3   variable
;background                           IX-15      3   variable
;G_7                                  IX-12      3   variable
;G_9                                   IX-9      3   variable
;G_1                                   IX-6      3   variable
;decompressorVar                       IX-3      3   variable


; Stack Frame Size: 58 (bytes)
;       Spill Code: 0 (instruction)


	SEGMENT STRSECT
L__50:
	DB	"U is ded lol."
	DB	0
	XREF _electricSheet_tiles_compressed:ROM
	XREF _zapperSheet_tiles_compressed:ROM
	XREF _coinSheet_tiles_compressed:ROM
	XREF _exhaustSheet_tiles_compressed:ROM
	XREF _avatarSheet_tiles_compressed:ROM
	XREF _nozzle_compressed:ROM
	XREF _background_compressed:ROM
	XREF _beam_compressed:ROM
	XREF _global_palette:ROM
	XREF _kb_Scan:ROM
	XREF _gfx_RotateSpriteHalf:ROM
	XREF _gfx_FlipSpriteY:ROM
	XREF _gfx_FlipSpriteX:ROM
	XREF _gfx_TransparentSprite_NoClip:ROM
	XREF _gfx_TransparentSprite:ROM
	XREF _gfx_Sprite:ROM
	XREF _gfx_SetTextFGColor:ROM
	XREF _gfx_SetTextXY:ROM
	XREF _gfx_PrintStringXY:ROM
	XREF _gfx_PrintInt:ROM
	XREF _gfx_SetTextScale:ROM
	XREF _gfx_SwapDraw:ROM
	XREF _gfx_SetDraw:ROM
	XREF _gfx_FillRectangle:ROM
	XREF _gfx_SetPalette:ROM
	XREF _gfx_SetTransparentColor:ROM
	XREF _gfx_SetColor:ROM
	XREF _gfx_End:ROM
	XREF _gfx_Begin:ROM
	XREF _gfx_AllocSprite:ROM
	XREF _zx7_Decompress:ROM
	XREF _abs:ROM
	XREF _free:ROM
	XREF _malloc:ROM
	XREF _os_GetCSC:ROM
	XREF _delay:ROM
	XREF _random:ROM
	XREF __ladd:ROM
	XREF __idivs:ROM
	XREF __ldivu:ROM
	XREF __iremu:ROM
	XREF __stoi:ROM
	XREF __stoiu:ROM
	XREF __frameset0:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __icmpzero:ROM
	XREF __imul_b:ROM
	XREF __ladd_b:ROM
	XDEF _main
	XDEF _spawnZapper
	XDEF _spawnCoin
	XDEF _rect
	XDEF _coin
	XDEF _coinAnimate
	XDEF _coinY
	XDEF _coinX
	XDEF _electric
	XDEF _zapper
	XDEF _zapperAnimate
	XDEF _zapperLength
	XDEF _zapperX
	XDEF _zapperY
	XDEF _randVar1
	XDEF _randVar
	XDEF _distance
	XDEF _monies
	XDEF _health
	XDEF _backgroundScroll
	XDEF _scrollSpeed
	XDEF _holdTime
	XDEF _frameTime
	XDEF _flightTime
	XDEF _exhaust
	XDEF _displacement
	XDEF _avatarAnimate
	XDEF _avatar
	XDEF _avatarY
	XDEF _avatarX
	XDEF _i_the_sequal
	XDEF _i
	XDEF _electricBuffer
	XDEF _electricBuffer_data
	XDEF _zappBuffer
	XDEF _zappBuffer_data
	XDEF _cty
	XDEF _ctx
	END
