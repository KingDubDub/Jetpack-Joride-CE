; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\JETPACK_JOYRIDE.C"
	.assume ADL=1
	SEGMENT TEXT
_abbreviatedMax:
	DB	30
	DB	21
	DB	24
	DB	26
	DB	17
	DB	30
_ctx:
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	144
	DB	0
	DW	156
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	108
	DB	0
	DW	120
	DB	0
	DW	144
	DB	0
	DW	156
	DB	0
	DW	180
	DB	0
	DW	192
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	108
	DB	0
	DW	120
	DB	0
	DW	180
	DB	0
	DW	192
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	84
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	108
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	84
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	24
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	96
	DB	0
	DW	12
	DB	0
	DW	36
	DB	0
	DW	60
	DB	0
	DW	84
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	96
	DB	0
	DW	12
	DB	0
	DW	36
	DB	0
	DW	60
	DB	0
	DW	84
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	96
	DB	0
	DW	12
	DB	0
	DW	36
	DB	0
	DW	60
	DB	0
	DW	84
	DB	0
	DW	108
	DB	0
_cty:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	12
	DB	12
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	36
	DB	36
	DB	36
	DB	36
	DB	48
	DB	48
	DB	48
	DB	48
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	48
	DB	48
	DB	60
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	12
	DB	12
	DB	24
	DB	24
	DB	36
	DB	36
	DB	36
	DB	48
	DB	48
	DB	60
	DB	60
	DB	60
	DB	60
	DB	72
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	48
	DB	48
	DB	48
	DB	48
	DB	48
	DB	60
	DB	60
	DB	60
	DB	60
	DB	60
	SEGMENT BSS
_i:
	DS	1
_avatarX:
	DS	2*1
_avatarY:
	DS	1
_avatar:
	DS	12
	SEGMENT DATA
_avatarAnimate:
	DB	1
_displacement:
	DB	3
	SEGMENT BSS
_exhaust:
	DS	18
	SEGMENT DATA
_flightTime:
	DB	18
	SEGMENT BSS
_frameTime:
	DS	1
_holdTime:
	DS	1
	SEGMENT DATA
_scrollSpeed:
	DB	5
_spawnDelay:
	DW	100
	DB	0
	SEGMENT BSS
_backgroundScroll:
	DS	3
_health:
	DS	1
_monies:
	DS	4*1
_distance:
	DS	4*1
_randVar:
	DS	1
_randVar1:
	DS	1
_randObject:
	DS	1
_zapperY:
	DS	9
	SEGMENT DATA
_zapperX:
	DW	330
	DW	460
	DW	0
	SEGMENT BSS
_zapperLength:
	DS	3
_beamCount:
	DS	1
_zapperAnimate:
	DS	3
_zapper:
	DS	18
_electric:
	DS	24
_coinX:
	DS	90
_coinY:
	DS	30
_coinFormation:
	DS	1
_coinAnimate:
	DS	30
_coin:
	DS	12
_missileX:
	DS	2
_missileY:
	DS	1
_warning:
	DS	9
_incoming:
	DS	6
_missileAnimate:
	DS	1
	SEGMENT DATA
_MAvalue:
	DB	255
;    1	#include <stdbool.h>
;    2	#include <stddef.h>
;    3	#include <stdint.h>
;    4	#include <tice.h>
;    5	
;    6	#include <math.h>
;    7	#include <stdio.h>
;    8	#include <stdlib.h>
;    9	#include <string.h>
;   10	
;   11	#include <compression.h>
;   12	#include <graphx.h>
;   13	#include <keypadc.h>
;   14	
;   15	#include "sprites/gfx.h"
;   16	#include "coinShapes.c"
;   17	
;   18	//max number of zappers:
;   19	#define MaxZappers 3
;   20	
;   21	//mas number of missiles, will probably be replaced with a non-static value later:
;   22	#define MaxMissiles 1
;   23	
;   24	//the most overused variable ever:
;   25	uint8_t i;
;   26	
;   27	//the Jetpack Joyride guy's name is Barry Steakfries, which is what I would name
;   28	//my child if I had the desire to marry and have children.
;   29	uint16_t avatarX;
;   30	uint8_t avatarY;
;   31	
;   32	//avatar's sprite array and values for keeping track of animation frames:
;   33	gfx_sprite_t *avatar[4];
;   34	int8_t avatarAnimate = 1;
;   35	int8_t displacement = 3;
;   36	
;   37	//exhaust/flame sprite array for jetpack flight animations:
;   38	gfx_sprite_t *exhaust[6];
;   39	
;   40	//variable used for calculating fire animations:
;   41	uint8_t flightTime = 18;
;   42	
;   43	//time it takes to complete the game loop, used to control the FPS; if it overflows
;   44	//then we have real problems:
;   45	uint8_t frameTime;
;   46	
;   47	//variables for when jetpack is on or not for math calculations:
;   48	int8_t holdTime;
;   49	
;   50	//speed of scrolling for avatar, obstacles, map, etc.
;   51	uint8_t scrollSpeed = 5;
;   52	
;   53	//measures timings for delays between spawning coins, obstacles, etc.:
;   54	int24_t spawnDelay = 100;
;   55	
;   56	//used for a bad background scroll function that is actually the best for this scenario:
;   57	int24_t backgroundScroll;
;   58	
;   59	//stores if Barry done got wasted or not:
;   60	uint8_t health;
;   61	
;   62	//max monies at $4,294,967,295:
;   63	uint32_t monies;
;   64	
;   65	//there's a limit to the distance you can fly in the original game, not sure I'll keep that or not...
;   66	uint32_t distance;
;   67	
;   68	//for randomization values that need to be reused:
;   69	uint8_t randVar;
;   70	uint8_t randVar1;
;   71	
;   72	uint8_t randObject;
;   73	
;   74	//arrays for zapper coordinates:
;   75	uint24_t zapperY[MaxZappers];
;   76	uint16_t zapperX[MaxZappers] = {330, 460};
;   77	//measured in beam units, 10x10 pixels:
;   78	uint8_t zapperLength[MaxZappers];
;   79	//used to draw zapper beam segments:
;   80	uint8_t beamCount;
;   81	//zapper animation count, all start at zero:
;   82	uint8_t zapperAnimate[MaxZappers];
;   83	gfx_sprite_t *zapper[6];
;   84	
;   85	//sprite array for electrical flares around zapper nodes:
;   86	gfx_sprite_t *electric[8];
;   87	
;   88	uint24_t coinX[MaxCoins];
;   89	uint8_t coinY[MaxCoins];
;   90	//coin formation variable to keep track of coin lists:
;   91	uint8_t coinFormation;
;   92	//values for keeping track of coin animation sprites, all start at zero:
;   93	uint8_t coinAnimate[MaxCoins];
;   94	gfx_sprite_t *coin[4];
;   95	
;   96	uint16_t missileX[MaxMissiles];
;   97	uint8_t missileY[MaxMissiles];
;   98	//missile warning sprite array (the red exclamation marks):
;   99	gfx_sprite_t *warning[3];
;  100	//missile incoming sprite array (exclamation marks with emphasis):
;  101	gfx_sprite_t *incoming[2];
;  102	//keep track of animations for missiles:
;  103	uint8_t missileAnimate;
;  104	int8_t MAvalue = -1;
	SEGMENT CODE
;  105	
;  106	
;  107	
;  108	//clears all objects from gameplay:
;  109	void delObjects()
;  110	{
_delObjects:
	LD	HL,-6
	CALL	__frameset
;  111	    for (i = 0; i < abbreviatedMax[coinFormation]; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_2
L_0:
;  112	    {
;  113	        coinX[i] = 2000;
	LD	A,(_i)
	UEXT	HL
	LD	BC,2000
	LD	(IX+-6),BC	; spill
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	BC,(IX+-6)	; unspill
	LD	(HL),BC
;  114	        coinY[i] = 0;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinY
	ADD	HL,BC
	LD	(HL),0
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  115	    }
L_2:
	LD	A,(_coinFormation)
	UEXT	HL
	LD	L,A
	LD	BC,_abbreviatedMax
	ADD	HL,BC
	LD	A,(_i)
	CP	A,(HL)
	JR	C,L_0
;  116	
;  117	    for (i = 0; i < MaxZappers; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_5
L_3:
;  118	    {
;  119	        zapperLength[i] = 0;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	(HL),0
;  120	        zapperX[i] = 2000;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	(HL),208
	INC	HL
	LD	(HL),7
;  121	        zapperY[i] = 0;
	LD	A,(_i)
	UEXT	HL
	LD	DE,0
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	(HL),DE
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  122	    }
L_5:
	LD	A,(_i)
	CP	A,3
	JR	C,L_3
;  123	
;  124	    for (i = 0; i < MaxMissiles; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_9
L_7:
;  125	    {
;  126	        missileX[i] = 6001;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_missileX
	ADD	HL,BC
	LD	(HL),113
	INC	HL
	LD	(HL),23
;  127	        missileY[i] = 0;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_missileY
	ADD	HL,BC
	LD	(HL),0
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  128	    }
L_9:
	LD	A,(_i)
	CP	A,1
	JR	C,L_7
;  129	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _delObjects ***************************
;Name                         Addr/Register   Size   Type
;_missileY                           STATIC      1   variable
;_missileX                           STATIC      2   variable
;_zapperY                            STATIC      9   variable
;_zapperX                            STATIC      6   variable
;_zapperLength                       STATIC      3   variable
;_coinFormation                      STATIC      1   variable
;_abbreviatedMax                     IMPORT      6   variable
;_coinY                              STATIC     30   variable
;_coinX                              STATIC     90   variable
;_i                                  STATIC      1   variable


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  130	
;  131	
;  132	
;  133	void main(void)
;  134	{
_main:
	LD	HL,-91
	CALL	__frameset
;  135	    //make background sprite variables and a quick decompression slot:
;  136	    gfx_sprite_t *background, *sparkle, *nozzle, *beam, *missile, *decompressorVar;
;  137	
;  138	    background = gfx_MallocSprite(192, 240);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,240
	PUSH	BC
	LD	BC,192
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-21),HL
;  139	    zx7_Decompress(background, background_compressed);
	LD	BC,_background_compressed
	PUSH	BC
	LD	BC,(IX+-21)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  140	
;  141	    //sparkle effect left by picked up coins:
;  142	    sparkle = gfx_MallocSprite(16, 15);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,15
	PUSH	BC
	LD	BC,16
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-42),HL
;  143	    zx7_Decompress(sparkle, sparkle_compressed);
	LD	BC,_sparkle_compressed
	PUSH	BC
	LD	BC,(IX+-42)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  144	
;  145	    //jetpack nozzle that glows when releasing exhaust:
;  146	    nozzle = gfx_MallocSprite(nozzle_width, nozzle_height);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,7
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-33),HL
;  147	    zx7_Decompress(nozzle, nozzle_compressed);
	LD	BC,_nozzle_compressed
	PUSH	BC
	LD	BC,(IX+-33)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  148	
;  149	    //zapper beam:
;  150	    beam = gfx_MallocSprite(10, 10);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,10
	PUSH	BC
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-36),HL
;  151	    zx7_Decompress(beam, beam_compressed);
	LD	BC,_beam_compressed
	PUSH	BC
	LD	BC,(IX+-36)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  152	
;  153	    //temporary missile sprite:
;  154	    missile = gfx_MallocSprite(46, 38);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,38
	PUSH	BC
	LD	BC,46
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-30),HL
;  155	    zx7_Decompress(missile, missile_compressed);
	LD	BC,_missile_compressed
	PUSH	BC
	LD	BC,(IX+-30)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  156	
;  157	    //sprite decompression, sorted by loop time:
;  158	
;  159	    for(i=0; i < 8; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_14
L_12:
;  160	    {
;  161	        //mallocing full electric array:
;  162	        electric[i] = gfx_MallocSprite(32, 32);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,32
	PUSH	BC
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_electric
	ADD	HL,DE
	LD	(HL),BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  163	    }
L_14:
	LD	A,(_i)
	CP	A,8
	JR	C,L_12
;  164	
;  165	    for(i = 0; i < 2; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_17
L_15:
;  166	    {
;  167	        //missile incoming symbol:
;  168	        decompressorVar = gfx_MallocSprite(31, 31);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,31
	PUSH	BC
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  169	        zx7_Decompress(decompressorVar, missileIncoming_tiles_compressed[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_missileIncoming_tiles_compressed
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  170	        incoming[i] = decompressorVar;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_incoming
	ADD	HL,BC
	LD	BC,(IX+-3)
	LD	(HL),BC
;  171	
;  172	        //zapper lightning:
;  173	        zx7_Decompress(electric[i], electricSheet_tiles_compressed[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,BC
	LD	DE,_electricSheet_tiles_compressed
	ADD	HL,DE
	LD	DE,(HL)
	PUSH	DE
	LD	HL,BC
	LD	BC,_electric
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  174	        gfx_FlipSpriteX(electric[i], electric[i+2]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	INC	HL
	INC	HL
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteX
	POP	BC
	POP	BC
;  175	        gfx_FlipSpriteY(electric[i], electric[i+4]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	HL,IY+4
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteY
	POP	BC
	POP	BC
;  176	        gfx_RotateSpriteHalf(electric[i], electric[i+6]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	HL,IY+6
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_RotateSpriteHalf
	POP	BC
	POP	BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  177	    }
L_17:
	LD	A,(_i)
	CP	A,2
	JR	C,L_15
;  178	
;  179	    for(i = 0; i < 3; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_21
L_19:
;  180	    {
;  181	        //missile warning symbols:
;  182	        decompressorVar = gfx_MallocSprite(20, 21);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,21
	PUSH	BC
	LD	BC,20
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  183	        zx7_Decompress(decompressorVar, missileWarning_tiles_compressed[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_missileWarning_tiles_compressed
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  184	        warning[i] = decompressorVar;
	LD	BC,(IX+-3)
;  185	
;  186	        //zappers:
;  187	        zapper[i] = gfx_MallocSprite(18, 18);
	LD	DE,_malloc
	PUSH	DE
	LD	DE,18
	PUSH	DE
	PUSH	DE
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_warning
	ADD	HL,DE
	LD	(HL),BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
;  188	        zapper[i+3] = gfx_MallocSprite(18, 18);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,18
	PUSH	BC
	PUSH	BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_zapper
	ADD	HL,DE
	LD	(HL),BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	HL,IY+3
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_zapper
	ADD	HL,DE
	LD	(HL),BC
;  189	        zx7_Decompress(zapper[i], zapperSheet_tiles_compressed[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,BC
	LD	DE,_zapperSheet_tiles_compressed
	ADD	HL,DE
	LD	DE,(HL)
	PUSH	DE
	LD	HL,BC
	LD	BC,_zapper
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  190	        gfx_FlipSpriteX(zapper[i], zapper[i+3]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	HL,IY+3
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapper
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapper
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteX
	POP	BC
	POP	BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  191	    }
L_21:
	LD	A,(_i)
	CP	A,3
	JR	C,L_19
;  192	
;  193	    decompressorVar = gfx_MallocSprite(18,18);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,18
	PUSH	BC
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
;  194	    zx7_Decompress(decompressorVar, zapperSheet_tiles_compressed[2]);
	LD	IY,_zapperSheet_tiles_compressed
	LD	(IX+-3),HL
	LD	BC,(IY+6)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  195	    zapper[2] = decompressorVar;
	LD	HL,_zapper+6
	LD	BC,(IX+-3)
	LD	(HL),BC
;  196	
;  197	    for(i = 0; i < 4; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_26
L_24:
;  198	    {
;  199	        //decompressing avatar spritesheet:
;  200	        decompressorVar = gfx_MallocSprite(30, 40);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,40
	PUSH	BC
	LD	BC,30
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  201	        zx7_Decompress(decompressorVar, avatarSheet_tiles_compressed[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_avatarSheet_tiles_compressed
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  202	        avatar[i] = decompressorVar;
	LD	BC,(IX+-3)
;  203	
;  204	        //decompressing coin spritesheet:
;  205	        decompressorVar = gfx_MallocSprite(12, 12);
	LD	DE,_malloc
	PUSH	DE
	LD	DE,12
	PUSH	DE
	PUSH	DE
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_avatar
	ADD	HL,DE
	LD	(HL),BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  206	        zx7_Decompress(decompressorVar, coinSheet_tiles_compressed[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_coinSheet_tiles_compressed
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  207	        coin[i] = decompressorVar;
	LD	A,(_i)
	UEXT	HL
	LD	BC,(IX+-3)
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_coin
	ADD	HL,DE
	LD	(HL),BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  208	    }
L_26:
	LD	A,(_i)
	CP	A,4
	JR	C,L_24
;  209	
;  210	    //jetpack exhaust:
;  211	    for(i = 0; i < 6; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_29
L_27:
;  212	    {
;  213	        decompressorVar = gfx_MallocSprite(11, 23);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,23
	PUSH	BC
	LD	BC,11
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+-3),HL
;  214	        zx7_Decompress(decompressorVar, exhaustSheet_tiles_compressed[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_exhaustSheet_tiles_compressed
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_zx7_Decompress
	POP	BC
	POP	BC
;  215	        exhaust[i] = decompressorVar;
	LD	A,(_i)
	UEXT	HL
	LD	BC,(IX+-3)
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_exhaust
	ADD	HL,DE
	LD	(HL),BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  216	    }
L_29:
	LD	A,(_i)
	CP	A,6
	JR	C,L_27
;  217	
;  218	    //initialize GFX libraries:
;  219	    gfx_Begin();
	CALL	_gfx_Begin
;  220	    gfx_SetDrawBuffer();
	LD	BC,1
	PUSH	BC
	CALL	_gfx_SetDraw
	POP	BC
;  221	
;  222	    gfx_SetPalette(global_palette, sizeof_global_palette, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,512
	PUSH	BC
	LD	BC,_global_palette
	PUSH	BC
	CALL	_gfx_SetPalette
	POP	BC
	POP	BC
	POP	BC
;  223	    gfx_SetTransparentColor(0);
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTransparentColor
	POP	BC
;  224	
;  225	    //start up a timer for FPS monitoring, do not move:
;  226	    timer_Control = TIMER1_ENABLE | TIMER1_32K | TIMER1_UP;
	LD	HL,15859760
	LD	(HL),3
	INC	HL
;  227	
;  228	    //best scan mode according to Mateo:
;  229	    kb_SetMode(MODE_3_CONTINUOUS);
;  230	
;  231	    //all text printed is gray:
;  232	    gfx_SetTextFGColor(2);
	LD	BC,2
	PUSH	BC
	LD	(HL),2
	LD	A,(16056320)
	AND	A,252
	OR	A,3
	LD	(16056320),A
	CALL	_gfx_SetTextFGColor
	POP	BC
;  233	
;  234	    //when I first started using C, I asked some friends if there were GOTO statements.
;  235	    //They proved they were good friends, and told me "No, that's stupid". I'm glad they lied.
;  236	    GAMESTART:
L_32:
;  237	    //But it's still sometimes okay.
;  238	
;  239	    //reset variables for when a game starts:
;  240	    avatarX = 24;
	LD	HL,_avatarX
	LD	(HL),24
	INC	HL
	LD	(HL),0
;  241	    avatarY = 185;
	LD	A,185
	LD	(_avatarY),A
;  242	    holdTime = 0;
	XOR	A,A
	LD	(_holdTime),A
;  243	    flightTime = 18;
	LD	A,18
	LD	(_flightTime),A
;  244	    health = 1;
	LD	A,1
	LD	(_health),A
;  245	    spawnDelay = 100;
	LD	BC,100
	LD	(_spawnDelay),BC
;  246	    distance = 0;
	LD	BC,0
	LD	(_distance),BC
	XOR	A,A
	LD	(_distance+3),A
;  247	    monies = 0;
	LD	(_monies),BC
	XOR	A,A
	LD	(_monies+3),A
;  248	
;  249	    delObjects();
	CALL	_delObjects
;  250	
;  251	    // Loop until clear is pressed:
;  252	    do{
L_146:
;  253	        //update keys, fixes bugs with update errors that can lead to softlocks:
;  254	        kb_Scan();
	CALL	_kb_Scan
;  255	
;  256	        if ((backgroundScroll - scrollSpeed) <= 0)
	LD	A,(_scrollSpeed)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(_backgroundScroll)
	OR	A,A
	SBC	HL,BC
	LD	(IX+-60),HL
	LD	BC,HL
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_34
;  257	        {
;  258	            backgroundScroll += (192 - scrollSpeed);
	LD	A,(_scrollSpeed)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,192
	OR	A,A
	SBC	HL,BC
	LD	BC,(_backgroundScroll)
	ADD	HL,BC
	LD	(_backgroundScroll),HL
;  259	        } else {
	JR	L_55
L_34:
;  260	            backgroundScroll -= scrollSpeed;
	LD	BC,(IX+-60)
	LD	(_backgroundScroll),BC
;  261	        }
L_55:
;  262	
;  263	        //spawns stuff, SO much better than the debug methods I originally used:
;  264	        if (spawnDelay <= 0)
	LD	BC,(_spawnDelay)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_54
;  265	        {
;  266	            randObject = randInt(1,10);
	CALL	_random
	LD	BC,10
	CALL	__iremu
	INC	HL
	LD	A,L
;  267	
;  268	            if (randObject == 1)
	CP	A,1
	LD	(_randObject),A
	JR	NZ,L_52
;  269	            {
;  270	                //sets coin coordinates from coordinate lists:
;  271	                randVar = randInt(30, 150);
	CALL	_random
	LD	BC,121
	CALL	__iremu
	LD	IY,HL
	LEA	HL,IY+30
	LD	A,L
	LD	(_randVar),A
;  272	                coinFormation = randInt(0, 5);
	CALL	_random
	LD	BC,6
	CALL	__iremu
	LD	A,L
	LD	(_coinFormation),A
;  273	                for(i = 0; i < MaxCoins; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_37
L_35:
;  274	                {
;  275	                    coinX[i] = ctx[coinFormation][i] + 330;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	A,(_coinFormation)
	UEXT	HL
	LD	L,A
	LD	A,90
	CALL	__imul_b
	LD	DE,_ctx
	ADD	HL,DE
	ADD	HL,BC
	LD	IY,HL
	LD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	(IX+-81),IY	; spill
	LD	(IX+-84),HL	; spill
	LD	IY,(IX+-81)	; unspill
	LD	HL,(IY)
	LD	BC,330
	ADD	HL,BC
	LD	IY,(IX+-84)	; unspill
	LD	(IY),HL
;  276	                    coinY[i] = cty[coinFormation][i] + randVar;
	LD	A,(_coinFormation)
	UEXT	HL
	LD	L,A
	LD	A,30
	CALL	__imul_b
	LD	BC,_cty
	ADD	HL,BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinY
	ADD	HL,BC
	LD	A,(IY)
	LD	BC,(_randVar)
	ADD	A,C
	LD	(HL),A
;  277	                    coinAnimate[i] = 0;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinAnimate
	ADD	HL,BC
	LD	(HL),0
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  278	                }
L_37:
	LD	A,(_i)
	CP	A,30
	JR	C,L_35
;  279	
;  280	                spawnDelay = 500;
	LD	BC,500
	LD	(_spawnDelay),BC
;  281	
;  282	            } else if (randObject == 2) {
	JR	L_78
L_52:
	LD	A,(_randObject)
	CP	A,2
	JR	NZ,L_50
;  283	
;  284	                //spawns missiles (and missile swarms if I implement them):
;  285	                for (i = 0; i < MaxMissiles; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_42
L_40:
;  286	                {
;  287	                    if (missileX[i] > 6000)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_missileX
	ADD	HL,BC
	LD	(IX+-63),HL
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,6000
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_41
;  288	                    {
;  289	                        missileX[i] = 1466;
	LD	HL,(IX+-63)
	LD	(HL),186
	INC	HL
	LD	(HL),5
;  290	                        missileY[i] = 10 * randInt(2, 18);
	CALL	_random
	LD	BC,17
	CALL	__iremu
	INC	HL
	INC	HL
	LD	B,L
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	C,10
	LD	DE,_missileY
	ADD	HL,DE
	MLT	BC
	LD	(HL),C
;  291	
;  292	                        i = MaxZappers;
	LD	A,3
	LD	(_i),A
;  293	                    }
;  294	                }
L_41:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_42:
	LD	A,(_i)
	CP	A,1
	JR	C,L_40
	JR	L_78
;  295	
;  296	                //missiles have their own "delay" and don't need to reset spawnDelay.
;  297	
;  298	            } else if (randObject <= 10) {
L_50:
	LD	A,10
	LD	HL,_randObject
	CP	A,(HL)
	JR	C,L_78
;  299	
;  300	                //randomly generates zapper coordinates and lengths:
;  301	                for (i = 0; i < MaxZappers; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_46
L_44:
;  302	                {
;  303	                    if (zapperX[i] > 330)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	(IX+-39),HL
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,330
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_45
;  304	                    {
;  305	                        zapperX[i] = 330;
	LD	HL,(IX+-39)
	LD	(HL),74
	INC	HL
	LD	(HL),1
;  306	
;  307	                        zapperLength[i] = randInt(2, 4);
	CALL	_random
	LD	A,(_i)
	LD	BC,3
	CALL	__iremu
	INC	HL
	INC	HL
	LD	B,L
	UEXT	HL
	LD	L,A
	LD	DE,_zapperLength
	ADD	HL,DE
	LD	(HL),B
;  308	                        zapperY[i] = 10 * randInt(2, 19 - zapperLength[i]);
	CALL	_random
	LD	DE,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,10
	LD	BC,HL
	LD	HL,19
	OR	A,A
	SBC	HL,BC
	LD	BC,HL
	LD	HL,DE
	DEC	BC
	CALL	__iremu
	INC	HL
	INC	HL
	CALL	__imul_b
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
;  309	
;  310	                        i = MaxZappers;
	LD	A,3
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_zapperY
	ADD	HL,DE
	LD	(HL),BC
	LD	(_i),A
;  311	                    }
;  312	                }
L_45:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_46:
	LD	A,(_i)
	CP	A,3
	JR	C,L_44
;  313	
;  314	                spawnDelay = 200;
	LD	BC,200
	LD	(_spawnDelay),BC
;  315	            }
;  316	        } else {
	JR	L_78
L_54:
;  317	            spawnDelay -= scrollSpeed;
	LD	A,(_scrollSpeed)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(_spawnDelay)
	OR	A,A
	SBC	HL,BC
	LD	(_spawnDelay),HL
;  318	        }
L_78:
;  319	
;  320	        //run controls until Barry gets wasted, then bounces his corpse around:
;  321	        if (health > 0)
	XOR	A,A
	LD	HL,_health
	CP	A,(HL)
	JR	NC,L_86
;  322	        {
;  323	            if (kb_Data[1] & kb_2nd)
	LD	A,(16056338)
	AND	A,32
	JR	Z,L_70
;  324	            {
;  325	                if((avatarY > 20) && (holdTime < 12))
	LD	A,20
	LD	HL,_avatarY
	CP	A,(HL)
	JR	NC,L_59
	LD	A,(_holdTime)
	CP	A,12
	JP	P,L_59
;  326	                {
;  327	                    holdTime += 1;
	LD	A,(_holdTime)
	INC	A
	LD	(_holdTime),A
;  328	                }
L_59:
;  329	
;  330	                if (flightTime > 7)
	LD	A,7
	LD	HL,_flightTime
	CP	A,(HL)
	JR	NC,L_61
;  331	                {
;  332	                    flightTime = 0;
	XOR	A,A
	LD	(_flightTime),A
;  333	                }
L_61:
;  334	
;  335	                if (flightTime < 7)
	LD	A,(_flightTime)
	CP	A,7
	JR	NC,L_71
;  336	                {
;  337	                    ++flightTime;
	LD	A,(_flightTime)
	INC	A
	LD	(_flightTime),A
;  338	                }
;  339	
;  340	            } else {
	JR	L_71
L_70:
;  341	
;  342	                if((avatarY < (185)) && (holdTime > -10))
	LD	A,(_avatarY)
	CP	A,185
	JR	NC,L_68
	LD	A,246
	LD	HL,_holdTime
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_68
;  343	                {
;  344	                    holdTime -= 1;
	LD	A,(_holdTime)
	DEC	A
	LD	(_holdTime),A
;  345	                }
L_68:
;  346	
;  347	                if (flightTime < 7)
	LD	A,(_flightTime)
	CP	A,7
	JR	NC,L_67
;  348	                {
;  349	                    flightTime = 8;
	LD	A,8
	LD	(_flightTime),A
;  350	
;  351	                } else if (flightTime < 11) {
	JR	L_71
L_67:
	LD	A,(_flightTime)
	CP	A,11
	JR	NC,L_65
;  352	
;  353	                    ++flightTime;
	LD	A,(_flightTime)
	INC	A
	LD	(_flightTime),A
;  354	
;  355	                } else {
	JR	L_71
L_65:
;  356	
;  357	                    flightTime = 18;
	LD	A,18
	LD	(_flightTime),A
;  358	                }
;  359	            }
L_71:
;  360	
;  361	            //SAX got pretty mad about this part, turns out a linear equation can model a curve and
;  362	            //is actually better than a cubic function:
;  363	            avatarY -= (holdTime);
	LD	BC,(_holdTime)
	LD	A,(_avatarY)
	SUB	A,C
	LD	(_avatarY),A
;  364	
;  365	            //sees if Y-value rolled past zero or 198, figures out if it was going up
;  366	            //or down, and auto-corrects accordingly:
;  367	            if ((avatarY > (186)) || (avatarY < 20))
	LD	A,186
	LD	HL,_avatarY
	CP	A,(HL)
	JR	C,L_76
	LD	A,(_avatarY)
	CP	A,20
	JR	NC,L_86
L_76:
;  368	            {
;  369	                if (holdTime > 0)
	XOR	A,A
	LD	HL,_holdTime
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_74
;  370	                {
;  371	                    avatarY = 20;
	LD	A,20
	LD	(_avatarY),A
;  372	                } else {
	JR	L_75
L_74:
;  373	                    avatarY = 185;
	LD	A,185
	LD	(_avatarY),A
;  374	                }
L_75:
;  375	                holdTime = 0;
	XOR	A,A
	LD	(_holdTime),A
;  376	            }
;  377	        }
L_86:
;  378	
;  379	        //bit that runs avatar animations:
;  380	        if (avatarY < 185)
	LD	A,(_avatarY)
	CP	A,185
	JR	NC,L_85
;  381	        {
;  382	            displacement = 9;
	LD	A,9
	LD	(_displacement),A
;  383	        } else {
	JR	L_87
L_85:
;  384	
;  385	            if (displacement == 9)
	LD	A,(_displacement)
	CP	A,9
	JR	NZ,L_82
;  386	            {
;  387	                displacement = 3;
	LD	A,3
	LD	(_displacement),A
;  388	            }
L_82:
;  389	
;  390	            if((displacement < 1) || (displacement > 7))
	LD	A,(_displacement)
	CP	A,1
	CALL	__setflag
	JP	M,L_81
	LD	A,7
	LD	HL,_displacement
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_83
L_81:
;  391	            {
;  392	                avatarAnimate *= -1;
	LD	A,(_avatarAnimate)
	NEG	
	LD	(_avatarAnimate),A
;  393	            }
L_83:
;  394	
;  395	            displacement += avatarAnimate;
	LD	BC,(_avatarAnimate)
	LD	A,(_displacement)
	ADD	A,C
	LD	(_displacement),A
;  396	        }
L_87:
;  397	
;  398	        //this is the best way I've found to draw the backgrounds, smaller and faster than a smart system:
;  399	        gfx_Sprite(background, backgroundScroll - 192, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,16777024
	LD	HL,(_backgroundScroll)
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+-21)
	PUSH	BC
	CALL	_gfx_Sprite
	POP	BC
	POP	BC
	POP	BC
;  400	        gfx_Sprite(background, backgroundScroll, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,(_backgroundScroll)
	PUSH	BC
	LD	BC,(IX+-21)
	PUSH	BC
	CALL	_gfx_Sprite
	POP	BC
	POP	BC
	POP	BC
;  401	        gfx_Sprite(background, backgroundScroll + 192, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,192
	LD	HL,(_backgroundScroll)
	ADD	HL,BC
	PUSH	HL
	LD	BC,(IX+-21)
	PUSH	BC
	CALL	_gfx_Sprite
	POP	BC
	POP	BC
	POP	BC
;  402	
;  403	        //bit that runs coin collision and movement:
;  404	        for(i = 0; i < abbreviatedMax[coinFormation]; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_100
L_98:
;  405	        {
;  406	            if (coinX[i] < 1000)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	(IX+-9),HL
	OR	A,A
	LD	HL,(HL)
	LD	BC,1000
	SBC	HL,BC
	JR	NC,L_99
;  407	            {
;  408	                //collision detection and appropriate sprite drawing:
;  409	                if (coinX[i] < 330)
	LD	HL,(IX+-9)
	LD	HL,(HL)
	LD	BC,330
	OR	A,A
	SBC	HL,BC
	JR	NC,L_96
;  410	                {
;  411	                    if (gfx_CheckRectangleHotspot(avatarX+6,avatarY,18,40,coinX[i]-11,coinY[i]+1,10,10))
	LD	BC,(IX+-9)
	LD	(IX+-51),BC
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+24
	OR	A,A
	LD	HL,(IX+-9)
	LD	IY,(HL)
	LEA	HL,IY+-11
	SBC	HL,BC
	JR	NC,L_94
	LD	BC,(IX+-9)
	LD	(IX+-51),BC
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,HL
	LEA	HL,IY+6
	LD	IY,(IX+-9)
	LD	BC,(IY)
	DEC	BC
	OR	A,A
	SBC	HL,BC
	JR	NC,L_94
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinY
	ADD	HL,BC
	LD	(IX+-24),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	INC	BC
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	DE,IY+40
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	CALL	__setflag
	JP	P,L_94
	LD	HL,(IX+-24)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	OR	A,A
	LEA	BC,IY+11
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_94
;  412	                    {
;  413	                        gfx_TransparentSprite(sparkle, coinX[i]-13, coinY[i]-1);
	LD	HL,(IX+-24)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	DEC	HL
	PUSH	HL
	LD	HL,(IX+-9)
	LD	IY,(HL)
	LEA	BC,IY+-13
	PUSH	BC
	LD	BC,(IX+-42)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  414	
;  415	                        coinX[i] = 1020;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	BC,1020
	LD	(HL),BC
;  416	                        ++monies;
	LD	A,(_monies+3)
	LD	E,A
	LD	A,1
	LD	HL,(_monies)
	CALL	__ladd_b
	LD	(_monies),HL
	LD	A,E
	LD	(_monies+3),A
;  417	                    } else {
	JR	L_96
L_94:
;  418	                        gfx_TransparentSprite(coin[(coinAnimate[i]/10)], (coinX[i]-12), coinY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinAnimate
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+-51)
	LD	IY,(IY)
	ADD	HL,BC
	LD	BC,_coin
	ADD	HL,BC
	LEA	BC,IY+-12
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  419	
;  420	                        if (coinAnimate[i] < 38)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinAnimate
	ADD	HL,BC
	LD	(IX+-18),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,38
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_92
;  421	                        {
;  422	                            coinAnimate[i] += 2;
	LD	HL,(IX+-18)
	LD	A,(HL)
	INC	A
	INC	A
	LD	HL,(IX+-18)
	LD	(HL),A
;  423	                        } else {
	JR	L_96
L_92:
;  424	                            coinAnimate[i] = 0;
	LD	HL,(IX+-18)
	LD	(HL),0
;  425	                        }
;  426	                    }
;  427	                }
L_96:
;  428	
;  429	                coinX[i] -= scrollSpeed;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	(IX+-66),HL
	LD	A,(_scrollSpeed)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-66)
	LD	HL,(HL)
	LD	IY,(IX+-66)
	OR	A,A
	SBC	HL,BC
	LD	(IY),HL
;  430	            }
;  431	        }
L_99:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_100:
	LD	A,(_coinFormation)
	UEXT	HL
	LD	L,A
	LD	BC,_abbreviatedMax
	ADD	HL,BC
	LD	A,(_i)
	CP	A,(HL)
	JR	C,L_98
;  432	
;  433	        //bit that calculates zappers 'n stuff:
;  434	        for (i = 0; i < MaxZappers; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_117
L_115:
;  435	        {
;  436	            //drawing the zapper beams:
;  437	            if (zapperX[i] < 1000)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,1000
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_116
;  438	            {
;  439	                for (beamCount = 0; beamCount < zapperLength[i]; ++beamCount)
	XOR	A,A
	LD	(_beamCount),A
	JR	L_103
L_101:
;  440	                {
;  441	                    gfx_TransparentSprite(beam, zapperX[i]-14, zapperY[i]+16+(beamCount*10));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_beamCount)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LEA	BC,IY+16
	ADD	HL,BC
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+-14
	PUSH	BC
	LD	BC,(IX+-36)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
	LD	A,(_beamCount)
	INC	A
	LD	(_beamCount),A
;  442	                }
L_103:
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(_beamCount)
	CP	A,(HL)
	JR	C,L_101
;  443	
;  444	                //draw zapper pairs and beams with distance of zapperLength between them:
;  445	                if (zapperX[i] < 336)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	(IX+-27),HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,336
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_113
;  446	                {
;  447	                    randVar = randInt(0,1);
	CALL	_random
	LD	A,L
	AND	A,1
	LD	(_randVar),A
;  448	                    randVar1 = randInt(0,1);
	CALL	_random
	LD	A,L
	AND	A,1
	LD	(_randVar1),A
;  449	
;  450	                    gfx_TransparentSprite(electric[randVar+2+(randVar1*4)], zapperX[i]-25, zapperY[i]-7);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LEA	BC,IY+-7
	PUSH	BC
	LD	IY,HL
	LD	A,(_randVar1)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	A,(_randVar)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	INC	BC
	INC	BC
	LD	HL,DE
	ADD	HL,BC
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric
	ADD	HL,BC
	LEA	BC,IY+-25
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  451	                    gfx_TransparentSprite(electric[randVar+(randVar1*4)], zapperX[i]-25,  zapperY[i]+7+(zapperLength[i]*10));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LEA	BC,IY+7
	ADD	HL,BC
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LD	A,(_randVar1)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	LD	BC,HL
	LD	A,(_randVar)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric
	ADD	HL,BC
	LEA	BC,IY+-25
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  452	
;  453	                    gfx_TransparentSprite(zapper[(zapperAnimate[i]/10)+3], zapperX[i]-18, zapperY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperAnimate
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LEA	BC,IY+-18
	PUSH	BC
	LD	IY,HL
	LEA	HL,IY+3
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapper
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  454	                    gfx_TransparentSprite(zapper[zapperAnimate[i]/10], zapperX[i]-18, zapperY[i]+14+(zapperLength[i]*10));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LEA	BC,IY+14
	ADD	HL,BC
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperAnimate
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapper
	ADD	HL,BC
	LEA	BC,IY+-18
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  455	
;  456	                    if (zapperAnimate[i] < 28)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperAnimate
	ADD	HL,BC
	LD	(IX+-15),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,28
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_105
;  457	                    {
;  458	                        zapperAnimate[i] += 2;
	LD	HL,(IX+-15)
	LD	A,(HL)
	INC	A
	INC	A
	LD	HL,(IX+-15)
	LD	(HL),A
;  459	                    } else {
	JR	L_110
L_105:
;  460	                        zapperAnimate[i] = 0;
	LD	HL,(IX+-15)
	LD	(HL),0
;  461	                    }
L_110:
;  462	
;  463	                    //collision for zappers:
;  464	                    if (gfx_CheckRectangleHotspot(avatarX+6, zapperY[i]+2, 18, (zapperLength[i]*10)+30, zapperX[i]-14, avatarY, 10, 50))
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	(IX+-27),HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	(IX+-45),HL
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,(IX+-45)
	LD	BC,(IY)
	LD	IY,HL
	LEA	DE,IY+24
	CALL	__stoiu
	LD	IY,HL
	LEA	HL,IY+-14
	OR	A,A
	SBC	HL,DE
	CALL	__setflag
	JP	P,L_113
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,(IX+-45)
	LD	BC,(IY)
	LD	IY,HL
	CALL	__stoiu
	LEA	DE,IY+6
	LD	BC,HL
	DEC	BC
	DEC	BC
	DEC	BC
	DEC	BC
	OR	A,A
	LD	HL,DE
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_113
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LEA	BC,IY+2
	LD	(IX+-48),BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LD	IY,HL
	LEA	HL,IY+30
	LD	BC,(IX+-48)
	ADD	HL,BC
	LD	BC,HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	OR	A,A
	SBC	HL,BC
	JR	NC,L_113
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+50
	LD	HL,(IX+-48)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_113
;  465	                    {
;  466	                        --health;
	LD	A,(_health)
	DEC	A
	LD	(_health),A
;  467	                    }
;  468	                }
L_113:
;  469	
;  470	                zapperX[i] -= scrollSpeed;
	LD	BC,(IX+-27)
	LD	HL,_zapperX
	ADD	HL,BC
	LD	(IX+-69),HL
	LD	HL,(HL)
	LD	A,(_scrollSpeed)
	OR	A,A
	LD	C,A
	LD	B,0
	SBC.SIS	HL,BC
	LD	BC,HL
	LD	HL,(IX+-69)
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  471	            }
;  472	        }
L_116:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_117:
	LD	A,(_i)
	CP	A,3
	JR	C,L_115
;  473	
;  474	        //bit that draws and calculates the missiles 'o death:
;  475	        for (i = 0; i < MaxMissiles; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_138
L_136:
;  476	        {
;  477	            if (missileX[i] < 6001)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_missileX
	ADD	HL,BC
	LD	(IX+-12),HL
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,6001
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_137
;  478	            {
;  479	                if (missileX[i] < 366)
	LD	HL,(IX+-12)
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,366
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_130
;  480	                {
;  481	                    gfx_TransparentSprite(missile, missileX[i]-46, missileY[i]-19);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_missileY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+-19
	PUSH	BC
	LD	HL,(IX+-12)
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+-46
	PUSH	BC
	LD	BC,(IX+-30)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  482	
;  483	                    if (gfx_CheckRectangleHotspot(missileX[i]-45, avatarY, 19, 40, avatarX+6, missileY[i]-5, 18, 12))
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_missileX
	ADD	HL,BC
	LD	(IX+-54),HL
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,(IX+-54)
	LD	BC,(IY)
	LD	IY,HL
	LEA	DE,IY+6
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+-26
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_133
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,(IX+-54)
	LD	BC,(IY)
	LD	IY,HL
	CALL	__stoiu
	LEA	BC,IY+24
	LD	IY,HL
	LEA	HL,IY+-45
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_133
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_missileY
	ADD	HL,BC
	LD	(IX+-57),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LEA	BC,IY+-5
	LD	IY,HL
	LEA	DE,IY+40
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	CALL	__setflag
	JP	P,L_133
	LD	HL,(IX+-57)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	OR	A,A
	LEA	BC,IY+7
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_133
;  484	                    {
;  485	                        --health;
	LD	A,(_health)
	DEC	A
	LD	(_health),A
;  486	                    }
;  487	
;  488	                } else if (missileX[i] < 641) {
	JR	L_133
L_130:
	LD	HL,(IX+-12)
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,641
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_128
;  489	
;  490	                    //AW CRAP HERE COME DAT BOI!
;  491	                    gfx_TransparentSprite(incoming[missileAnimate/3], 281+randInt(-1,1), missileY[i]-16+randInt(-1,1));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_missileY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+-16
	LD	(IX+-78),BC	; spill
	CALL	_random
	LD	BC,3
	CALL	__iremu
	LD	BC,HL
	DEC	BC
	LD	(IX+-75),BC	; spill
	LD	HL,(IX+-78)
	LD	BC,(IX+-75)	; unspill
	ADD	HL,BC
	PUSH	HL
	CALL	_random
	LD	BC,3
	CALL	__iremu
	LD	BC,280
	ADD	HL,BC
	PUSH	HL
	LD	A,(_missileAnimate)
	UEXT	HL
	LD	L,A
	LD	BC,3
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_incoming
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  492	
;  493	                } else if (missileX[i] < 1467) {
	JR	L_133
L_128:
	LD	HL,(IX+-12)
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,1467
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_133
;  494	
;  495	                    //plenty of time to dodge (at the beginning at least)
;  496	                    gfx_TransparentSprite(warning[missileAnimate/2], 293, missileY[i]-11);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_missileY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LD	A,(_missileAnimate)
	UEXT	HL
	LD	L,A
	LD	BC,2
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LEA	BC,IY+-11
	PUSH	BC
	LD	BC,_warning
	ADD	HL,BC
	LD	BC,293
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  497	
;  498	                    //tracking on avatar
;  499	                    if (missileY[i] < (avatarY + 20))
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_missileY
	ADD	HL,BC
	LD	(IX+-6),HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LD	IY,(IX+-6)
	LD	A,(IY)
	LD	IY,HL
	UEXT	HL
	LD	L,A
	OR	A,A
	LEA	BC,IY+20
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_125
;  500	                    {
;  501	                        missileY[i] += 2;
	LD	HL,(IX+-6)
	LD	A,(HL)
	INC	A
	INC	A
	LD	HL,(IX+-6)
	LD	(HL),A
;  502	                    } else if (missileY[i] > (avatarY + 21)) {
	JR	L_133
L_125:
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LD	IY,(IX+-6)
	LD	A,(IY)
	LD	IY,HL
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LEA	HL,IY+21
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_133
;  503	                        missileY[i] -= 2;
	LD	HL,(IX+-6)
	LD	A,(HL)
	DEC	A
	DEC	A
	LD	HL,(IX+-6)
	LD	(HL),A
;  504	                    }
;  505	                }
L_133:
;  506	
;  507	                //make missileAnimate go up and down between 0 and 5 by toggling MAvalue:
;  508	                if ((missileAnimate < 1) || (missileAnimate > 4))
	LD	A,(_missileAnimate)
	CP	A,1
	JR	C,L_132
	LD	A,4
	LD	HL,_missileAnimate
	CP	A,(HL)
	JR	NC,L_134
L_132:
;  509	                {
;  510	                    MAvalue *= -1;
	LD	A,(_MAvalue)
	NEG	
	LD	(_MAvalue),A
;  511	                }
L_134:
;  512	                missileAnimate += MAvalue;
	LD	BC,(_missileAnimate)
	LD	A,(_MAvalue)
	ADD	A,C
	LD	(_missileAnimate),A
;  513	
;  514	                //missiles travel by 6 pixels each frame. It was surprisingly tedious to figure that out
;  515	                //from frame-by-frame reviewing of missiles.
;  516	                missileX[i] -= scrollSpeed + 8;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_missileX
	ADD	HL,BC
	LD	(IX+-72),HL
	LD	A,(_scrollSpeed)
	LD	C,A
	LD	B,0
	LD	IY,BC
	LD	HL,(IX+-72)
	LD	HL,(HL)
	LEA	BC,IY+8
	OR	A,A
	SBC.SIS	HL,BC
	LD	BC,HL
	LD	HL,(IX+-72)
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  517	            }
;  518	        }
L_137:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_138:
	LD	A,(_i)
	CP	A,1
	JR	C,L_136
;  519	
;  520	        //draws the avatar after a few hundred lines of code:
;  521	        gfx_TransparentSprite_NoClip(avatar[displacement/3], avatarX, avatarY-abs((displacement/3)-1));
	LD	A,(_displacement)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,3
	CALL	__idivs
	DEC	HL
	PUSH	HL
	CALL	_abs
	POP	BC
	LD	A,(_avatarY)
	SUB	A,L
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,(_avatarX)
	LD	A,(_displacement)
	LD	D,A
	CALL	__stoiu
	PUSH	HL
	SEXT	HL
	LD	L,D
	LD	BC,3
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_avatar
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
;  522	
;  523	        //bit that draws exhaust when in flight:
;  524	        if (flightTime < 18)
	LD	A,(_flightTime)
	CP	A,18
	JR	NC,L_142
;  525	        {
;  526	            gfx_TransparentSprite_NoClip(exhaust[flightTime/2], avatarX+randInt(1,3), avatarY+31);
	LD	A,(_avatarY)
	ADD	A,31
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_random
	LD	BC,3
	CALL	__iremu
	LD	DE,HL
	INC	DE
	LD	BC,(_avatarX)
	CALL	__stoiu
	ADD	HL,DE
	PUSH	HL
	LD	A,(_flightTime)
	UEXT	HL
	LD	L,A
	LD	BC,2
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_exhaust
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
;  527	            gfx_TransparentSprite_NoClip(nozzle, avatarX+4, avatarY+31);
	LD	A,(_avatarY)
	ADD	A,31
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+4
	PUSH	BC
	LD	BC,(IX+-33)
	PUSH	BC
	CALL	_gfx_TransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
;  528	        }
L_142:
;  529	
;  530	        //FPS counter:
;  531	        frameTime = (32768 / timer_1_Counter);
	LD	HL,32768
	LD	E,0
	LD	BC,(15859712)
	LD	A,(15859715)
	CALL	__ldivu
	LD	BC,HL
	LD	A,C
	LD	(_frameTime),A
;  532	
;  533	        if (frameTime > 25)
	LD	A,25
	LD	HL,_frameTime
	CP	A,(HL)
	JR	NC,L_144
;  534	        {
;  535	            delay(40 - (1000/frameTime));
	LD	A,(_frameTime)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,1000
	CALL	__idivs
	LD	BC,HL
	LD.LIS	HL,40
	OR	A,A
	SBC.SIS	HL,BC
	PUSH	HL
	CALL	_delay
	POP	BC
;  536	        }
L_144:
;  537	
;  538	        timer_1_Counter = 0;
;  539	
;  540	        gfx_SetTextScale(1, 1);
	LD	BC,1
	PUSH	BC
	PUSH	BC
	LD	BC,0
	LD	(15859712),BC
	XOR	A,A
	LD	(15859715),A
	CALL	_gfx_SetTextScale
	POP	BC
	POP	BC
;  541	        gfx_SetTextXY(280, 10);
	LD	BC,10
	PUSH	BC
	LD	BC,280
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  542	        gfx_PrintInt(frameTime, 2);
	LD	A,(_frameTime)
	UEXT	HL
	LD	BC,2
	PUSH	BC
	LD	L,A
	PUSH	HL
	LD	(IX+-91),A
	CALL	_gfx_PrintInt
	LD	A,(IX+-91)
	POP	BC
	POP	BC
;  543	
;  544	        gfx_SetTextXY(10, 30);
	LD	BC,30
	PUSH	BC
	LD	BC,10
	PUSH	BC
	LD	(IX+-91),A
	CALL	_gfx_SetTextXY
	LD	A,(IX+-91)
	POP	BC
	POP	BC
;  545	        gfx_PrintInt(monies, 4);
	LD	BC,4
	PUSH	BC
	LD	BC,(_monies)
	PUSH	BC
	LD	(IX+-91),A
	CALL	_gfx_PrintInt
	LD	A,(IX+-91)
	POP	BC
	POP	BC
;  546	
;  547	        gfx_SetTextScale(2,2);
	LD	BC,2
	PUSH	BC
	PUSH	BC
	LD	(IX+-91),A
	CALL	_gfx_SetTextScale
	LD	A,(IX+-91)
	POP	BC
	POP	BC
;  548	        gfx_SetTextXY(10, 10);
	LD	BC,10
	PUSH	BC
	PUSH	BC
	LD	(IX+-91),A
	CALL	_gfx_SetTextXY
	LD	A,(IX+-91)
	POP	BC
	POP	BC
;  549	        gfx_PrintInt((distance += scrollSpeed)/15, 4);
	UEXT	HL
	LD	A,(_scrollSpeed)
	LD	L,A
	LD	A,(_distance+3)
	LD	E,A
	LD	BC,HL
	LD	A,H
	LD	HL,(_distance)
	CALL	__ladd
	LD	(_distance),HL
	LD	A,E
	LD	(_distance+3),A
	LD	E,A
	XOR	A,A
	LD	BC,15
	LD	(IX+-87),HL	; spill
	LD	HL,4
	LD	(IX+-90),HL	; spill
	LD	HL,(IX+-87)	; unspill
	LD	(IX+-87),HL	; spill
	LD	HL,(IX+-90)	; unspill
	PUSH	HL
	LD	HL,(IX+-87)	; unspill
	CALL	__ldivu
	PUSH	HL
	CALL	_gfx_PrintInt
	POP	BC
	POP	BC
;  550	
;  551	        //gfx_BlitBuffer();
;  552	        gfx_SwapDraw();
	CALL	_gfx_SwapDraw
;  553	
;  554	    } while (!(kb_Data[6] & kb_Clear) && (health > 0));
	LD	A,(16056348)
	AND	A,64
	JR	NZ,L_156
	XOR	A,A
	LD	HL,_health
	CP	A,(HL)
	JR	C,L_146
L_156:
;  555	
;  556	    if (health < 1)
	LD	A,(_health)
	CP	A,1
	JR	NC,L_157
;  557	    {
;  558	        gfx_FillScreen(1);
	LD	BC,1
	PUSH	BC
	CALL	_gfx_FillScreen
	POP	BC
;  559	        gfx_SetTextScale(4, 4);
	LD	BC,4
	PUSH	BC
	PUSH	BC
	CALL	_gfx_SetTextScale
	POP	BC
	POP	BC
;  560	        gfx_PrintStringXY("U is ded lol.", 15, 100);
	LD	BC,100
	PUSH	BC
	LD	BC,15
	PUSH	BC
	LD	BC,L__71
	PUSH	BC
	CALL	_gfx_PrintStringXY
	POP	BC
	POP	BC
	POP	BC
;  561	        gfx_SwapDraw();
	CALL	_gfx_SwapDraw
;  562	
;  563	        while (kb_AnyKey());
L_149:
	CALL	_kb_AnyKey
	OR	A,A
	JR	NZ,L_149
;  564	        while (!kb_AnyKey());
L_151:
	CALL	_kb_AnyKey
	OR	A,A
	JR	Z,L_151
;  565	
;  566	        if (kb_Data[6] != kb_Clear)
	LD	A,(16056348)
	CP	A,64
	JR	NZ,L_32
;  567	        {
;  568	            goto GAMESTART;
;  569	        }
;  570	    }
L_157:
;  571	
;  572	    //erase the decompressed sprites, very important:
;  573	    free(background);
	LD	BC,(IX+-21)
	PUSH	BC
	CALL	_free
	POP	BC
;  574	    free(nozzle);
	LD	BC,(IX+-33)
	PUSH	BC
	CALL	_free
	POP	BC
;  575	    free(beam);
	LD	BC,(IX+-36)
	PUSH	BC
	CALL	_free
	POP	BC
;  576	    free(missile);
	LD	BC,(IX+-30)
	PUSH	BC
	CALL	_free
	POP	BC
;  577	    free(decompressorVar);
	LD	BC,(IX+-3)
	PUSH	BC
	CALL	_free
	POP	BC
;  578	
;  579	    //stop libraries, not doing so causes "interesting" results
;  580	    gfx_End();
	CALL	_gfx_End
;  581	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_gfx_End                            IMPORT  -----   function
;_free                               IMPORT  -----   function
;_kb_AnyKey                          IMPORT  -----   function
;_gfx_PrintStringXY                  IMPORT  -----   function
;_gfx_FillScreen                     IMPORT  -----   function
;_gfx_SwapDraw                       IMPORT  -----   function
;_gfx_PrintInt                       IMPORT  -----   function
;_gfx_SetTextXY                      IMPORT  -----   function
;_gfx_SetTextScale                   IMPORT  -----   function
;_delay                              IMPORT  -----   function
;_frameTime                          STATIC      1   variable
;_abs                                IMPORT  -----   function
;_gfx_TransparentSprite_NoClip       IMPORT  -----   function
;_MAvalue                            STATIC      1   variable
;_missileAnimate                     STATIC      1   variable
;_zapperAnimate                      STATIC      3   variable
;_randVar1                           STATIC      1   variable
;_beamCount                          STATIC      1   variable
;_abbreviatedMax                     IMPORT      6   variable
;_gfx_TransparentSprite              IMPORT  -----   function
;_gfx_Sprite                         IMPORT  -----   function
;_avatarAnimate                      STATIC      1   variable
;_displacement                       STATIC      1   variable
;_zapperY                            STATIC      9   variable
;_zapperLength                       STATIC      3   variable
;_zapperX                            STATIC      6   variable
;_missileY                           STATIC      1   variable
;_missileX                           STATIC      2   variable
;_coinAnimate                        STATIC     30   variable
;_coinY                              STATIC     30   variable
;_cty                                IMPORT    180   variable
;_coinX                              STATIC     90   variable
;_ctx                                IMPORT    540   variable
;_coinFormation                      STATIC      1   variable
;_randVar                            STATIC      1   variable
;_randObject                         STATIC      1   variable
;_random                             IMPORT  -----   function
;_scrollSpeed                        STATIC      1   variable
;_backgroundScroll                   STATIC      3   variable
;_kb_Scan                            IMPORT  -----   function
;_monies                             STATIC      4   variable
;_distance                           STATIC      4   variable
;_spawnDelay                         STATIC      3   variable
;_health                             STATIC      1   variable
;_flightTime                         STATIC      1   variable
;_holdTime                           STATIC      1   variable
;_avatarY                            STATIC      1   variable
;_avatarX                            STATIC      2   variable
;_gfx_SetTextFGColor                 IMPORT  -----   function
;_gfx_SetTransparentColor            IMPORT  -----   function
;_global_palette                     IMPORT    512   variable
;_gfx_SetPalette                     IMPORT  -----   function
;_gfx_SetDraw                        IMPORT  -----   function
;_gfx_Begin                          IMPORT  -----   function
;_exhaust                            STATIC     18   variable
;_exhaustSheet_tiles_compressed      IMPORT     18   variable
;_coin                               STATIC     12   variable
;_coinSheet_tiles_compressed         IMPORT     12   variable
;_avatar                             STATIC     12   variable
;_avatarSheet_tiles_compressed       IMPORT     12   variable
;_zapperSheet_tiles_compressed       IMPORT      9   variable
;_zapper                             STATIC     18   variable
;_warning                            STATIC      9   variable
;_missileWarning_tiles_compressed      IMPORT      9   variable
;_gfx_RotateSpriteHalf               IMPORT  -----   function
;_gfx_FlipSpriteY                    IMPORT  -----   function
;_gfx_FlipSpriteX                    IMPORT  -----   function
;_electricSheet_tiles_compressed      IMPORT      6   variable
;_incoming                           STATIC      6   variable
;_missileIncoming_tiles_compressed      IMPORT      6   variable
;_electric                           STATIC     24   variable
;_i                                  STATIC      1   variable
;_missile_compressed                 IMPORT    370   variable
;_beam_compressed                    IMPORT     14   variable
;_nozzle_compressed                  IMPORT     15   variable
;_sparkle_compressed                 IMPORT     67   variable
;_background_compressed              IMPORT    655   variable
;_zx7_Decompress                     IMPORT  -----   function
;_malloc                             IMPORT  -----   function
;_gfx_AllocSprite                    IMPORT  -----   function
;G_1                                  IX-63      3   variable
;G_0                                  IX-60      3   variable
;G_20                                 IX-57      3   variable
;G_19                                 IX-54      3   variable
;G_9                                  IX-51      3   variable
;G_15                                 IX-48      3   variable
;G_14                                 IX-45      3   variable
;sparkle                              IX-42      3   variable
;G_2                                  IX-39      3   variable
;beam                                 IX-36      3   variable
;nozzle                               IX-33      3   variable
;missile                              IX-30      3   variable
;G_16                                 IX-27      3   variable
;G_6                                  IX-24      3   variable
;background                           IX-21      3   variable
;G_10                                 IX-18      3   variable
;G_12                                 IX-15      3   variable
;G_17                                 IX-12      3   variable
;G_3                                   IX-9      3   variable
;G_23                                  IX-6      3   variable
;decompressorVar                       IX-3      3   variable


; Stack Frame Size: 97 (bytes)
;       Spill Code: -1 (instruction)


	SEGMENT STRSECT
L__71:
	DB	"U is ded lol."
	DB	0
	XREF _missile_compressed:ROM
	XREF _missileIncoming_tiles_compressed:ROM
	XREF _missileWarning_tiles_compressed:ROM
	XREF _electricSheet_tiles_compressed:ROM
	XREF _zapperSheet_tiles_compressed:ROM
	XREF _coinSheet_tiles_compressed:ROM
	XREF _exhaustSheet_tiles_compressed:ROM
	XREF _avatarSheet_tiles_compressed:ROM
	XREF _beam_compressed:ROM
	XREF _sparkle_compressed:ROM
	XREF _nozzle_compressed:ROM
	XREF _background_compressed:ROM
	XREF _global_palette:ROM
	XREF _kb_AnyKey:ROM
	XREF _kb_Scan:ROM
	XREF _gfx_RotateSpriteHalf:ROM
	XREF _gfx_FlipSpriteY:ROM
	XREF _gfx_FlipSpriteX:ROM
	XREF _gfx_TransparentSprite_NoClip:ROM
	XREF _gfx_TransparentSprite:ROM
	XREF _gfx_Sprite:ROM
	XREF _gfx_SetTextFGColor:ROM
	XREF _gfx_SetTextXY:ROM
	XREF _gfx_PrintStringXY:ROM
	XREF _gfx_PrintInt:ROM
	XREF _gfx_SetTextScale:ROM
	XREF _gfx_SwapDraw:ROM
	XREF _gfx_SetDraw:ROM
	XREF _gfx_FillScreen:ROM
	XREF _gfx_SetPalette:ROM
	XREF _gfx_SetTransparentColor:ROM
	XREF _gfx_End:ROM
	XREF _gfx_Begin:ROM
	XREF _gfx_AllocSprite:ROM
	XREF _zx7_Decompress:ROM
	XREF _abs:ROM
	XREF _free:ROM
	XREF _malloc:ROM
	XREF _delay:ROM
	XREF _random:ROM
	XREF __ladd:ROM
	XREF __idivs:ROM
	XREF __ldivu:ROM
	XREF __iremu:ROM
	XREF __stoiu:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __imul_b:ROM
	XREF __ladd_b:ROM
	XDEF _main
	XDEF _delObjects
	XDEF _MAvalue
	XDEF _missileAnimate
	XDEF _incoming
	XDEF _warning
	XDEF _missileY
	XDEF _missileX
	XDEF _coin
	XDEF _coinAnimate
	XDEF _coinFormation
	XDEF _coinY
	XDEF _coinX
	XDEF _electric
	XDEF _zapper
	XDEF _zapperAnimate
	XDEF _beamCount
	XDEF _zapperLength
	XDEF _zapperX
	XDEF _zapperY
	XDEF _randObject
	XDEF _randVar1
	XDEF _randVar
	XDEF _distance
	XDEF _monies
	XDEF _health
	XDEF _backgroundScroll
	XDEF _spawnDelay
	XDEF _scrollSpeed
	XDEF _holdTime
	XDEF _frameTime
	XDEF _flightTime
	XDEF _exhaust
	XDEF _displacement
	XDEF _avatarAnimate
	XDEF _avatar
	XDEF _avatarY
	XDEF _avatarX
	XDEF _i
	XDEF _cty
	XDEF _ctx
	XDEF _abbreviatedMax
	END
