; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\JETPACK_JOYRIDE_MAIN.C"
	.assume ADL=1
	SEGMENT TEXT
_coin_max:
	DB	30
	DB	21
	DB	24
	DB	26
	DB	17
	DB	30
_ctx:
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	144
	DB	0
	DW	156
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	108
	DB	0
	DW	120
	DB	0
	DW	144
	DB	0
	DW	156
	DB	0
	DW	180
	DB	0
	DW	192
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	108
	DB	0
	DW	120
	DB	0
	DW	180
	DB	0
	DW	192
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	84
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	108
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	84
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	24
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	96
	DB	0
	DW	12
	DB	0
	DW	36
	DB	0
	DW	60
	DB	0
	DW	84
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	96
	DB	0
	DW	12
	DB	0
	DW	36
	DB	0
	DW	60
	DB	0
	DW	84
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	96
	DB	0
	DW	12
	DB	0
	DW	36
	DB	0
	DW	60
	DB	0
	DW	84
	DB	0
	DW	108
	DB	0
_cty:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	12
	DB	12
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	36
	DB	36
	DB	36
	DB	36
	DB	48
	DB	48
	DB	48
	DB	48
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	48
	DB	48
	DB	60
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	12
	DB	12
	DB	24
	DB	24
	DB	36
	DB	36
	DB	36
	DB	48
	DB	48
	DB	60
	DB	60
	DB	60
	DB	60
	DB	72
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	48
	DB	48
	DB	48
	DB	48
	DB	48
	DB	60
	DB	60
	DB	60
	DB	60
	DB	60
_laserMax:
	DB	2
	DB	4
	DB	7
_lsrY:
	DB	24
	DB	204
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	24
	DB	54
	DB	84
	DB	204
	DB	0
	DB	0
	DB	0
	DB	24
	DB	54
	DB	84
	DB	114
	DB	144
	DB	174
	DB	204
_halfLife:
	DB	108
	DB	108
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	108
	DB	108
	DB	108
	DB	108
	DB	0
	DB	0
	DB	0
	DB	108
	DB	108
	DB	216
	DB	216
	DB	216
	DB	108
	DB	108
	SEGMENT BSS
_i:
	DS	1
_i_the_sequel:
	DS	1
_avatarX:
	DS	2*1
_avatarY:
	DS	1
	SEGMENT DATA
_avatarAnimate:
	DB	1
_displacement:
	DB	3
_flightTime:
	DB	18
	SEGMENT BSS
_frameTime:
	DS	1
_holdTime:
	DS	1
_scrollSpeed:
	DS	1
	SEGMENT DATA
_spawnDelay:
	DW	200
	DB	0
	SEGMENT BSS
_missileDelay:
	DS	1
_backgroundScroll:
	DS	3
_health:
	DS	1
_monies:
	DS	4*1
_distance:
	DS	4*1
_randVar:
	DS	1
_randVar1:
	DS	1
_randObject:
	DS	1
_coinX:
	DS	90
_coinY:
	DS	30
_coinFormation:
	DS	1
_coinAnimate:
	DS	30
_zapperY:
	DS	9
_zapperX:
	DS	6
_zapperLength:
	DS	3
_zapperAnimate:
	DS	3
_missileX:
	DS	2
_missileY:
	DS	1
_missileAnimate:
	DS	1
	SEGMENT DATA
_MAvalue:
	DB	255
	SEGMENT BSS
_laserX:
	DS	1
_laserY:
	DS	7
_laserLifetime:
	DS	21
_laserAnimate:
	DS	1
_laserFormation:
	DS	1
_deadLasers:
	DS	1
_zapper_tiles_flipped:
	DS	9
_electric_animation:
	DS	24
_powering_tiles_flipped:
	DS	12
_firing_tiles_flipped:
	DS	9
_shutdown_tiles_flipped:
	DS	9
;    1	/*Jetpack Joyride CE
;    2	
;    3	A Jetpack Joyride port for the TI-84 Plus CE calculators.
;    4	
;    5	Made by King Dub Dub
;    6	
;    7	I'm pretty sure you have the readme if you have this source code, but if you want
;    8	to mod this or something then get ready for some over-commented trash!
;    9	
;   10	In case it wasn't clear, modding this should have my permission and credit to me,
;   11	but other than that you are obliged to have as much fun as will kill you!
;   12	
;   13	*/
;   14	
;   15	#include <stdbool.h>
;   16	#include <stddef.h>
;   17	#include <stdint.h>
;   18	#include <tice.h>
;   19	
;   20	#include <math.h>
;   21	#include <stdio.h>
;   22	#include <stdlib.h>
;   23	#include <string.h>
;   24	
;   25	#include <compression.h>
;   26	#include <graphx.h>
;   27	#include <keypadc.h>
;   28	
;   29	#include "headers.h"
;   30	
;   31	//all the sprite include files:
;   32	#include "sprites/gfx.h"
;   33	
;   34	//quick-fix until convimg gets patched:
;   35	#include "sprites/RLET_laser.h"
;   36	
;   37	//max number of zappers:
;   38	#define MaxZappers 3
;   39	
;   40	//max number of missiles, will probably be replaced with a non-static value later:
;   41	#define MaxMissiles 1
;   42	
;   43	//the most overused variable ever:
;   44	uint8_t i;
;   45	
;   46	//and now there's two:
;   47	uint8_t i_the_sequel;
;   48	
;   49	//the Jetpack Joyride guy's name is Barry Steakfries, which is what I would name
;   50	//my child if I had the desire to marry and have children.
;   51	uint16_t avatarX;
;   52	uint8_t avatarY;
;   53	
;   54	//avatar's sprite array and values for keeping track of animation frames:
;   55	int8_t avatarAnimate = 1;
;   56	int8_t displacement = 3;
;   57	
;   58	//variable used for calculating fire animations:
;   59	uint8_t flightTime = 18;
;   60	
;   61	//time it takes to complete the game loop, used to control the FPS; if it overflows
;   62	//then we have real problems:
;   63	uint8_t frameTime;
;   64	
;   65	//variables for when jetpack is on or not for math calculations:
;   66	int8_t holdTime;
;   67	
;   68	//speed of scrolling for avatar, obstacles, map, etc.
;   69	uint8_t scrollSpeed;
;   70	
;   71	//measures timings for delays between spawning coins, obstacles, etc.:
;   72	int24_t spawnDelay = 200;
;   73	uint8_t missileDelay;
;   74	
;   75	//used for a bad background scroll function that is actually the best for this scenario:
;   76	int24_t backgroundScroll;
;   77	
;   78	//stores if Barry done got wasted or not:
;   79	int8_t health;
;   80	
;   81	//max monies at $4,294,967,295:
;   82	uint32_t monies;
;   83	
;   84	//there's a limit to the distance you can fly in the original game, not sure I'll keep that or not...
;   85	uint32_t distance;
;   86	
;   87	//for randomization values that need to be reused:
;   88	uint8_t randVar;
;   89	uint8_t randVar1;
;   90	
;   91	uint8_t randObject;
;   92	
;   93	uint24_t coinX[MaxCoins];
;   94	uint8_t coinY[MaxCoins];
;   95	//coin formation variable to keep track of coin lists:
;   96	uint8_t coinFormation;
;   97	//values for keeping track of coin animation sprites, all start at zero:
;   98	uint8_t coinAnimate[MaxCoins];
;   99	
;  100	//arrays for zapper coordinates:
;  101	uint24_t zapperY[MaxZappers];
;  102	uint16_t zapperX[MaxZappers];
;  103	//measured in beam units, 10x10 pixels:
;  104	uint8_t zapperLength[MaxZappers];
;  105	//zapper animation count, all start at zero:
;  106	uint8_t zapperAnimate[MaxZappers];
;  107	
;  108	uint16_t missileX[MaxMissiles];
;  109	uint8_t missileY[MaxMissiles];
;  110	//keep track of animations for missiles:
;  111	int8_t missileAnimate;
;  112	int8_t MAvalue = -1;
;  113	
;  114	//all lasers have a universal X that doesn't move very far:
;  115	int8_t laserX;
;  116	//laser Y array:
;  117	uint8_t laserY[MaxLasers];
;  118	//time till firing:
;  119	uint24_t laserLifetime[MaxLasers];
;  120	//keep track of laser animations:
;  121	int8_t laserAnimate;
;  122	//which laser formation is being used:
;  123	uint8_t laserFormation;
;  124	//keep track of how many lasers have fired already:
;  125	uint8_t deadLasers;
;  126	
;  127	//flipped sprites and animations:
;  128	gfx_sprite_t *zapper_tiles_flipped[3];
;  129	gfx_sprite_t *electric_animation[8];
;  130	gfx_sprite_t *powering_tiles_flipped[4];
;  131	gfx_sprite_t *firing_tiles_flipped[3];
;  132	gfx_sprite_t *shutdown_tiles_flipped[3];
	SEGMENT CODE
;  133	
;  134	
;  135	
;  136	//gfx_CheckRectangleHotspot but only the Y checks, since 4 C++ masters write better code than me:
;  137	#define Yspot(master_y, master_height, test_y, test_height) \
;  138	(((test_y) < ((master_y) + (master_height))) && \
;  139	(((test_y) + (test_height)) > (master_y)))
;  140	
;  141	//clears all objects from gameplay by moving their X-coords out of bounds:
;  142	void delObjects()
;  143	{
_delObjects:
;  144	    for (i = 0; i < coin_max[coinFormation]; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_2
L_0:
;  145	    {
;  146	        coinX[i] = 2000;
	LD	A,(_i)
	UEXT	HL
	LD	DE,2000
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	(HL),DE
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  147	    }
L_2:
	LD	A,(_coinFormation)
	UEXT	HL
	LD	L,A
	LD	BC,_coin_max
	ADD	HL,BC
	LD	A,(_i)
	CP	A,(HL)
	JR	C,L_0
;  148	
;  149	    for (i = 0; i < MaxZappers; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_5
L_3:
;  150	    {
;  151	        zapperLength[i] = 0;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	(HL),0
;  152	        zapperX[i] = 2000;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	(HL),208
	INC	HL
	LD	(HL),7
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  153	    }
L_5:
	LD	A,(_i)
	CP	A,3
	JR	C,L_3
;  154	
;  155	    for (i = 0; i < MaxMissiles; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_9
L_7:
;  156	    {
;  157	        missileX[i] = 6001;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_missileX
	ADD	HL,BC
	LD	(HL),113
	INC	HL
	LD	(HL),23
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  158	    }
L_9:
	LD	A,(_i)
	CP	A,1
	JR	C,L_7
;  159	
;  160	    laserX = 0;
	XOR	A,A
	LD	(_laserX),A
;  161	}
	RET	


;**************************** _delObjects ***************************
;Name                         Addr/Register   Size   Type
;_laserX                             STATIC      1   variable
;_missileX                           STATIC      2   variable
;_zapperX                            STATIC      6   variable
;_zapperLength                       STATIC      3   variable
;_coinFormation                      STATIC      1   variable
;_coin_max                           IMPORT      6   variable
;_coinX                              STATIC     90   variable
;_i                                  STATIC      1   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  162	
;  163	void main(void)
;  164	{
_main:
	LD	HL,-88
	CALL	__frameset
;  165	    //flipped zappers:
;  166	    for(i = 0; i < 3; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_15
L_13:
;  167	    {
;  168	        zapper_tiles_flipped[i] = gfx_MallocSprite(18, 18);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,18
	PUSH	BC
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_zapper_tiles_flipped
	ADD	HL,DE
	LD	(HL),BC
;  169	        gfx_FlipSpriteX(zapper_tiles[i], zapper_tiles_flipped[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,BC
	ADD	HL,DE
	LD	DE,(HL)
	PUSH	DE
	LD	HL,BC
	LD	BC,_zapper_tiles_data
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteX
	POP	BC
	POP	BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  170	    }
L_15:
	LD	A,(_i)
	CP	A,3
	JR	C,L_13
;  171	
;  172	    for(i=0; i < 8; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_18
L_16:
;  173	    {
;  174	        //mallocing full flipped electric_animation array:
;  175	        electric_animation[i] = gfx_MallocSprite(32, 32);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,32
	PUSH	BC
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_electric_animation
	ADD	HL,DE
	LD	(HL),BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  176	    }
L_18:
	LD	A,(_i)
	CP	A,8
	JR	C,L_16
;  177	
;  178	    for(i = 0; i < 2; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_22
L_20:
;  179	    {
;  180	        //zapper lightning:
;  181	        electric_animation[i] = electric_tiles[i];
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,BC
	LD	DE,_electric_tiles_data
	ADD	HL,DE
	LD	IY,HL
	LD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LD	BC,(IY)
	LD	(HL),BC
;  182	        gfx_FlipSpriteX(electric_animation[i], electric_animation[i+2]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	INC	HL
	INC	HL
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteX
	POP	BC
	POP	BC
;  183	        gfx_FlipSpriteY(electric_animation[i], electric_animation[i+4]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	HL,IY+4
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteY
	POP	BC
	POP	BC
;  184	        gfx_RotateSpriteHalf(electric_animation[i], electric_animation[i+6]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	HL,IY+6
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_RotateSpriteHalf
	POP	BC
	POP	BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  185	    }
L_22:
	LD	A,(_i)
	CP	A,2
	JR	C,L_20
;  186	
;  187	    //flipping laser powering up animations:
;  188	    for(i = 0; i < 4; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_26
L_24:
;  189	    {
;  190	        powering_tiles_flipped[i] = gfx_MallocSprite(19, 15);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,15
	PUSH	BC
	LD	BC,19
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_powering_tiles_flipped
	ADD	HL,DE
	LD	(HL),BC
;  191	        gfx_FlipSpriteY(powering_tiles[i], powering_tiles_flipped[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,BC
	ADD	HL,DE
	LD	DE,(HL)
	PUSH	DE
	LD	HL,BC
	LD	BC,_powering_tiles_data
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteY
	POP	BC
	POP	BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  192	    }
L_26:
	LD	A,(_i)
	CP	A,4
	JR	C,L_24
;  193	
;  194	    //flipping laser sprites:
;  195	    for(i = 0; i < 3; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_30
L_28:
;  196	    {
;  197	        firing_tiles_flipped[i] = gfx_MallocSprite(30, 37);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,37
	PUSH	BC
	LD	BC,30
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_firing_tiles_flipped
	ADD	HL,DE
	LD	(HL),BC
;  198	        gfx_FlipSpriteY(firing_tiles[i], firing_tiles_flipped[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,BC
	ADD	HL,DE
	LD	DE,(HL)
	PUSH	DE
	LD	HL,BC
	LD	BC,_firing_tiles_data
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteY
	POP	BC
	POP	BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  199	    }
L_30:
	LD	A,(_i)
	CP	A,3
	JR	C,L_28
;  200	
;  201	    for(i = 0; i < 3; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_34
L_32:
;  202	    {
;  203	        shutdown_tiles_flipped[i] = gfx_MallocSprite(30, 44);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,44
	PUSH	BC
	LD	BC,30
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_shutdown_tiles_flipped
	ADD	HL,DE
	LD	(HL),BC
;  204	        gfx_FlipSpriteY(shutdown_tiles[i], shutdown_tiles_flipped[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,BC
	ADD	HL,DE
	LD	DE,(HL)
	PUSH	DE
	LD	HL,BC
	LD	BC,_shutdown_tiles_data
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteY
	POP	BC
	POP	BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  205	    }
L_34:
	LD	A,(_i)
	CP	A,3
	JR	C,L_32
;  206	
;  207	    //initialize GFX libraries:
;  208	    gfx_Begin();
	CALL	_gfx_Begin
;  209	    gfx_SetDrawBuffer();
	LD	BC,1
	PUSH	BC
	CALL	_gfx_SetDraw
	POP	BC
;  210	
;  211	    gfx_SetPalette(jetpack_palette, sizeof_jetpack_palette, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,512
	PUSH	BC
	LD	BC,_jetpack_palette
	PUSH	BC
	CALL	_gfx_SetPalette
	POP	BC
	POP	BC
	POP	BC
;  212	    gfx_SetTransparentColor(0);
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTransparentColor
	POP	BC
;  213	
;  214	    //start up a timer for FPS monitoring, do not move:
;  215	    timer_Control = TIMER1_ENABLE | TIMER1_32K | TIMER1_UP;
	LD	HL,15859760
	LD	(HL),3
	INC	HL
	LD	(HL),2
;  216	
;  217	    //best scan mode according to the angry lettuce man:
;  218	    kb_SetMode(MODE_3_CONTINUOUS);
	LD	A,(16056320)
	AND	A,252
	OR	A,3
	LD	(16056320),A
;  219	
;  220	    //when I first started using C, I asked some friends if there were GOTO statements.
;  221	    //They proved they were good friends, and told me "No, that's stupid". I'm glad they lied.
;  222	    GAMESTART:
L_37:
;  223	    //But it's still sometimes okay.
;  224	
;  225	    //reset variables for when a game starts:
;  226	    scrollSpeed = 6;
	LD	A,6
	LD	(_scrollSpeed),A
;  227	    avatarX = 24;
	LD	HL,_avatarX
	LD	(HL),24
	INC	HL
	LD	(HL),0
;  228	    avatarY = 185;
	LD	A,185
	LD	(_avatarY),A
;  229	    holdTime = 0;
	XOR	A,A
	LD	(_holdTime),A
;  230	    flightTime = 18;
	LD	A,18
	LD	(_flightTime),A
;  231	    health = 1;
	LD	A,1
	LD	(_health),A
;  232	    spawnDelay = 100;
	LD	BC,100
	LD	(_spawnDelay),BC
;  233	    distance = 0;
	LD	BC,0
	LD	(_distance),BC
	XOR	A,A
	LD	(_distance+3),A
;  234	    monies = 0;
	LD	(_monies),BC
	XOR	A,A
	LD	(_monies+3),A
;  235	
;  236	    deadLasers = 10;
	LD	A,10
	LD	(_deadLasers),A
;  237	
;  238	    delObjects();
	CALL	_delObjects
;  239	
;  240	    // Loop until clear is pressed:
;  241	    do{
L_196:
;  242	        //update keys, fixes bugs with update errors that can lead to softlocks:
;  243	        kb_Scan();
	CALL	_kb_Scan
;  244	
;  245	        if ((backgroundScroll - scrollSpeed) <= 0)
	LD	A,(_scrollSpeed)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(_backgroundScroll)
	OR	A,A
	SBC	HL,BC
	LD	(IX+-54),HL
	LD	BC,HL
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_39
;  246	        {
;  247	            backgroundScroll += (192 - scrollSpeed);
	LD	A,(_scrollSpeed)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,192
	OR	A,A
	SBC	HL,BC
	LD	BC,(_backgroundScroll)
	ADD	HL,BC
	LD	(_backgroundScroll),HL
;  248	        } else {
	JR	L_68
L_39:
;  249	            backgroundScroll -= scrollSpeed;
	LD	BC,(IX+-54)
	LD	(_backgroundScroll),BC
;  250	        }
L_68:
;  251	
;  252	        //spawns stuff, SO much better than the debug methods I originally used:
;  253	        if (spawnDelay <= 0)
	LD	BC,(_spawnDelay)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_67
;  254	        {
;  255	            randObject = randInt(0,21);
	CALL	_random
	LD	BC,22
	CALL	__iremu
	LD	A,L
	LD	(_randObject),A
;  256	            //randObject = randInt(3,3);
;  257	
;  258	            if (randObject == 0)
	OR	A,A
	JR	NZ,L_65
;  259	            {
;  260	                laserFormation = randInt(0, 2);
	CALL	_random
	LD	BC,3
	CALL	__iremu
	LD	A,L
	LD	(_laserFormation),A
;  261	
;  262	                //give each laser their Y-axis:
;  263	                for(i = 0; i < laserMax[laserFormation]; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_42
L_40:
;  264	                {
;  265	                    laserY[i] = lsrY[laserFormation][i];
	LD	A,(_laserFormation)
	UEXT	HL
	LD	L,A
	LD	A,7
	CALL	__imul_b
	LD	BC,HL
	LD	HL,BC
	LD	DE,_lsrY
	ADD	HL,DE
	LD	DE,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,DE
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,_laserY
	ADD	HL,DE
	LD	A,(IY)
	LD	(HL),A
;  266	                    laserLifetime[i] = halfLife[laserFormation][i];
	LD	HL,BC
	LD	BC,_halfLife
	ADD	HL,BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_laserLifetime
	ADD	HL,DE
	LD	(HL),BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  267	                }
L_42:
	LD	A,(_laserFormation)
	UEXT	HL
	LD	L,A
	LD	BC,_laserMax
	ADD	HL,BC
	LD	A,(_i)
	CP	A,(HL)
	JR	C,L_40
;  268	
;  269	                laserX = 1;
	LD	A,1
	LD	(_laserX),A
;  270	
;  271	                deadLasers = 0;
	XOR	A,A
	LD	(_deadLasers),A
;  272	
;  273	                spawnDelay = scrollSpeed * 266;
	LD	A,(_scrollSpeed)
	UEXT	HL
	LD	L,A
	LD	BC,266
	CALL	__imuls
	LD	(_spawnDelay),HL
;  274	
;  275	            } else if (randObject < 4) {
	JR	L_91
L_65:
	LD	A,(_randObject)
	CP	A,4
	JR	NC,L_63
;  276	
;  277	                //sets coin coordinates from coordinate lists:
;  278	                randVar = randInt(30, 150);
	CALL	_random
	LD	BC,121
	CALL	__iremu
	LD	IY,HL
	LEA	HL,IY+30
	LD	A,L
	LD	(_randVar),A
;  279	                coinFormation = randInt(0, 5);
	CALL	_random
	LD	BC,6
	CALL	__iremu
	LD	A,L
	LD	(_coinFormation),A
;  280	                for(i = 0; i < MaxCoins; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_46
L_44:
;  281	                {
;  282	                    coinX[i] = ctx[coinFormation][i] + 330;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	A,(_coinFormation)
	UEXT	HL
	LD	L,A
	LD	A,90
	CALL	__imul_b
	LD	DE,_ctx
	ADD	HL,DE
	LD	DE,BC
	ADD	HL,DE
	LD	IY,HL
	LD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	(IX+-78),IY	; spill
	LD	(IX+-81),HL	; spill
	LD	IY,(IX+-78)	; unspill
	LD	HL,(IY)
	LD	BC,330
	ADD	HL,BC
	LD	IY,(IX+-81)	; unspill
	LD	(IY),HL
;  283	                    coinY[i] = cty[coinFormation][i] + randVar;
	LD	A,(_coinFormation)
	UEXT	HL
	LD	L,A
	LD	A,30
	CALL	__imul_b
	LD	BC,_cty
	ADD	HL,BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinY
	ADD	HL,BC
	LD	A,(IY)
	LD	BC,(_randVar)
	ADD	A,C
	LD	(HL),A
;  284	                    coinAnimate[i] = 0;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinAnimate
	ADD	HL,BC
	LD	(HL),0
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  285	                }
L_46:
	LD	A,(_i)
	CP	A,30
	JR	C,L_44
;  286	
;  287	                spawnDelay = 500;
	LD	BC,500
	LD	(_spawnDelay),BC
;  288	
;  289	            } else if (randObject < 7) {
	JR	L_91
L_63:
	LD	A,(_randObject)
	CP	A,7
	JR	NC,L_61
;  290	
;  291	                //spawns missiles (and missile swarms if I implement them):
;  292	                for (i = 0; i < MaxMissiles; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_51
L_49:
;  293	                {
;  294	                    if (missileX[i] > 6000)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_missileX
	ADD	HL,BC
	LD	(IX+-42),HL
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,6000
	OR	A,A
	SBC	HL,BC
	JP	P,L_50
;  295	                    {
;  296	                        missileX[i] = 1466;
	LD	HL,(IX+-42)
	LD	(HL),186
	INC	HL
	LD	(HL),5
;  297	                        missileY[i] = 10 * randInt(2, 18);
	CALL	_random
	LD	BC,17
	CALL	__iremu
	INC	HL
	INC	HL
	LD	B,L
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	C,10
	LD	DE,_missileY
	ADD	HL,DE
	MLT	BC
	LD	(HL),C
;  298	
;  299	                        i = MaxZappers;
	LD	A,3
	LD	(_i),A
;  300	                    }
;  301	                }
L_50:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_51:
	LD	A,(_i)
	CP	A,1
	JR	C,L_49
;  302	
;  303	                //missiles have their own delay that keeps things from spawning in that shouldn't,
;  304	                //such as coins and lasers:
;  305	                missileDelay = 1466;
	LD	A,186
	LD	(_missileDelay),A
;  306	
;  307	            } else if ((randObject > 3) && (randObject <= 20)) {
	JR	L_91
L_61:
	LD	A,3
	LD	HL,_randObject
	CP	A,(HL)
	JR	NC,L_91
	LD	A,20
	CP	A,(HL)
	JR	C,L_91
;  308	
;  309	                //randomly generates zapper coordinates and lengths:
;  310	                for (i = 0; i < MaxZappers; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_57
L_55:
;  311	                {
;  312	                    if (zapperX[i] > 330)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	(IX+-48),HL
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,330
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_56
;  313	                    {
;  314	                        zapperX[i] = 330;
	LD	HL,(IX+-48)
	LD	(HL),74
	INC	HL
	LD	(HL),1
;  315	
;  316	                        zapperLength[i] = randInt(2, 4);
	CALL	_random
	LD	A,(_i)
	LD	BC,3
	CALL	__iremu
	INC	HL
	INC	HL
	LD	B,L
	UEXT	HL
	LD	L,A
	LD	DE,_zapperLength
	ADD	HL,DE
	LD	(HL),B
;  317	                        zapperY[i] = 10 * randInt(2, 19 - zapperLength[i]);
	CALL	_random
	LD	DE,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,10
	LD	BC,HL
	LD	HL,19
	OR	A,A
	SBC	HL,BC
	LD	BC,HL
	LD	HL,DE
	DEC	BC
	CALL	__iremu
	INC	HL
	INC	HL
	CALL	__imul_b
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
;  318	
;  319	                        i = MaxZappers;
	LD	A,3
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_zapperY
	ADD	HL,DE
	LD	(HL),BC
	LD	(_i),A
;  320	                    }
;  321	                }
L_56:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_57:
	LD	A,(_i)
	CP	A,3
	JR	C,L_55
;  322	
;  323	                spawnDelay = 200;
	LD	BC,200
	LD	(_spawnDelay),BC
;  324	            }
;  325	        } else {
	JR	L_91
L_67:
;  326	            spawnDelay -= scrollSpeed;
	LD	A,(_scrollSpeed)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(_spawnDelay)
	OR	A,A
	SBC	HL,BC
	LD	(_spawnDelay),HL
;  327	            missileDelay -= scrollSpeed;
	LD	BC,(_scrollSpeed)
	LD	A,(_missileDelay)
	SUB	A,C
	LD	(_missileDelay),A
;  328	        }
L_91:
;  329	
;  330	        //run controls until Barry gets wasted, then bounces his corpse around:
;  331	        if (health > 0)
	XOR	A,A
	LD	HL,_health
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_99
;  332	        {
;  333	            if (kb_Data[1] & kb_2nd)
	LD	A,(16056338)
	AND	A,32
	JR	Z,L_83
;  334	            {
;  335	                if((avatarY > 20) && (holdTime < 12))
	LD	A,20
	LD	HL,_avatarY
	CP	A,(HL)
	JR	NC,L_72
	LD	A,(_holdTime)
	CP	A,12
	JP	P,L_72
;  336	                {
;  337	                    holdTime += 1;
	LD	A,(_holdTime)
	INC	A
	LD	(_holdTime),A
;  338	                }
L_72:
;  339	
;  340	                if (flightTime > 7)
	LD	A,7
	LD	HL,_flightTime
	CP	A,(HL)
	JR	NC,L_74
;  341	                {
;  342	                    flightTime = 0;
	XOR	A,A
	LD	(_flightTime),A
;  343	                }
L_74:
;  344	
;  345	                if (flightTime < 7)
	LD	A,(_flightTime)
	CP	A,7
	JR	NC,L_84
;  346	                {
;  347	                    ++flightTime;
	LD	A,(_flightTime)
	INC	A
	LD	(_flightTime),A
;  348	                }
;  349	
;  350	            } else {
	JR	L_84
L_83:
;  351	
;  352	                if((avatarY < (185)) && (holdTime > -10))
	LD	A,(_avatarY)
	CP	A,185
	JR	NC,L_81
	LD	A,246
	LD	HL,_holdTime
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_81
;  353	                {
;  354	                    holdTime -= 1;
	LD	A,(_holdTime)
	DEC	A
	LD	(_holdTime),A
;  355	                }
L_81:
;  356	
;  357	                if (flightTime < 7)
	LD	A,(_flightTime)
	CP	A,7
	JR	NC,L_80
;  358	                {
;  359	                    flightTime = 8;
	LD	A,8
	LD	(_flightTime),A
;  360	
;  361	                } else if (flightTime < 11) {
	JR	L_84
L_80:
	LD	A,(_flightTime)
	CP	A,11
	JR	NC,L_78
;  362	
;  363	                    ++flightTime;
	LD	A,(_flightTime)
	INC	A
	LD	(_flightTime),A
;  364	
;  365	                } else {
	JR	L_84
L_78:
;  366	
;  367	                    flightTime = 18;
	LD	A,18
	LD	(_flightTime),A
;  368	                }
;  369	            }
L_84:
;  370	
;  371	            //SAX got pretty mad about this part, turns out a linear equation can model a curve and
;  372	            //is actually better than a cubic function:
;  373	            avatarY -= (holdTime);
	LD	BC,(_holdTime)
	LD	A,(_avatarY)
	SUB	A,C
	LD	(_avatarY),A
;  374	
;  375	            //sees if Y-value rolled past zero or 198, figures out if it was going up
;  376	            //or down, and auto-corrects accordingly:
;  377	            if ((avatarY > (186)) || (avatarY < 20))
	LD	A,186
	LD	HL,_avatarY
	CP	A,(HL)
	JR	C,L_89
	LD	A,(_avatarY)
	CP	A,20
	JR	NC,L_99
L_89:
;  378	            {
;  379	                if (holdTime > 0)
	XOR	A,A
	LD	HL,_holdTime
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_87
;  380	                {
;  381	                    avatarY = 20;
	LD	A,20
	LD	(_avatarY),A
;  382	                } else {
	JR	L_88
L_87:
;  383	                    avatarY = 185;
	LD	A,185
	LD	(_avatarY),A
;  384	                }
L_88:
;  385	                holdTime = 0;
	XOR	A,A
	LD	(_holdTime),A
;  386	            }
;  387	        }
L_99:
;  388	
;  389	        //bit that runs avatar animations:
;  390	        if (avatarY < 185)
	LD	A,(_avatarY)
	CP	A,185
	JR	NC,L_98
;  391	        {
;  392	            displacement = 9;
	LD	A,9
	LD	(_displacement),A
;  393	        } else {
	JR	L_100
L_98:
;  394	
;  395	            if (displacement == 9)
	LD	A,(_displacement)
	CP	A,9
	JR	NZ,L_95
;  396	            {
;  397	                displacement = 3;
	LD	A,3
	LD	(_displacement),A
;  398	            }
L_95:
;  399	
;  400	            if((displacement < 1) || (displacement > 7))
	LD	A,(_displacement)
	CP	A,1
	CALL	__setflag
	JP	M,L_94
	LD	A,7
	LD	HL,_displacement
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_96
L_94:
;  401	            {
;  402	                avatarAnimate *= -1;
	LD	A,(_avatarAnimate)
	NEG	
	LD	(_avatarAnimate),A
;  403	            }
L_96:
;  404	
;  405	            displacement += avatarAnimate;
	LD	BC,(_avatarAnimate)
	LD	A,(_displacement)
	ADD	A,C
	LD	(_displacement),A
;  406	        }
L_100:
;  407	
;  408	        //this is the best way I've found to draw the backgrounds, smaller and faster than a smart system:
;  409	        gfx_Sprite(background, backgroundScroll - 192, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,16777024
	LD	HL,(_backgroundScroll)
	ADD	HL,BC
	PUSH	HL
	LD	BC,_background_data
	PUSH	BC
	CALL	_gfx_Sprite
	POP	BC
	POP	BC
	POP	BC
;  410	        gfx_Sprite(background, backgroundScroll, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,(_backgroundScroll)
	PUSH	BC
	LD	BC,_background_data
	PUSH	BC
	CALL	_gfx_Sprite
	POP	BC
	POP	BC
	POP	BC
;  411	        gfx_Sprite(background, backgroundScroll + 192, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,192
	LD	HL,(_backgroundScroll)
	ADD	HL,BC
	PUSH	HL
	LD	BC,_background_data
	PUSH	BC
	CALL	_gfx_Sprite
	POP	BC
	POP	BC
	POP	BC
;  412	
;  413	        //draws the avatar, everything is layered over it:
;  414	        gfx_TransparentSprite_NoClip(avatar_tiles[displacement/3], avatarX, avatarY-abs((displacement/3)-1));
	LD	A,(_displacement)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,3
	CALL	__idivs
	DEC	HL
	PUSH	HL
	CALL	_abs
	POP	BC
	LD	A,(_avatarY)
	SUB	A,L
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,(_avatarX)
	LD	A,(_displacement)
	LD	D,A
	CALL	__stoiu
	PUSH	HL
	SEXT	HL
	LD	L,D
	LD	BC,3
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_avatar_tiles_data
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
;  415	
;  416	        //bit that draws exhaust when in flight:
;  417	        if (flightTime < 18)
	LD	A,(_flightTime)
	CP	A,18
	JR	NC,L_115
;  418	        {
;  419	            gfx_TransparentSprite_NoClip(exhaust_tiles[flightTime/2], avatarX+randInt(1,3), avatarY+31);
	LD	A,(_avatarY)
	ADD	A,31
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_random
	LD	BC,3
	CALL	__iremu
	LD	DE,HL
	INC	DE
	LD	BC,(_avatarX)
	CALL	__stoiu
	ADD	HL,DE
	PUSH	HL
	LD	A,(_flightTime)
	UEXT	HL
	LD	L,A
	LD	BC,2
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_exhaust_tiles_data
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
;  420	            gfx_TransparentSprite_NoClip(nozzle, avatarX+4, avatarY+31);
	LD	A,(_avatarY)
	ADD	A,31
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+4
	PUSH	BC
	LD	BC,_nozzle_data
	PUSH	BC
	CALL	_gfx_TransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
;  421	        }
L_115:
;  422	
;  423	        //bit that runs coin collision and movement:
;  424	        for(i = 0; i < coin_max[coinFormation]; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_114
L_112:
;  425	        {
;  426	            if (coinX[i] < 1000)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	(IX+-3),HL
	OR	A,A
	LD	HL,(HL)
	LD	BC,1000
	SBC	HL,BC
	JR	NC,L_113
;  427	            {
;  428	                //collision detection and appropriate sprite drawing:
;  429	                if (coinX[i] < 330)
	LD	HL,(IX+-3)
	LD	HL,(HL)
	LD	BC,330
	OR	A,A
	SBC	HL,BC
	JR	NC,L_110
;  430	                {
;  431	                    if (gfx_CheckRectangleHotspot(avatarX+6,avatarY,18,40,coinX[i]-11,coinY[i]+1,10,10))
	LD	BC,(IX+-3)
	LD	(IX+-33),BC
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+24
	OR	A,A
	LD	HL,(IX+-3)
	LD	IY,(HL)
	LEA	HL,IY+-11
	SBC	HL,BC
	JR	NC,L_108
	LD	BC,(IX+-3)
	LD	(IX+-33),BC
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,HL
	LEA	HL,IY+6
	LD	IY,(IX+-3)
	LD	BC,(IY)
	DEC	BC
	OR	A,A
	SBC	HL,BC
	JR	NC,L_108
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinY
	ADD	HL,BC
	LD	(IX+-21),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	INC	BC
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	DE,IY+40
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	CALL	__setflag
	JP	P,L_108
	LD	HL,(IX+-21)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	OR	A,A
	LEA	BC,IY+11
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_108
;  432	                    {
;  433	                        gfx_RLETSprite(sparkle, coinX[i]-13, coinY[i]-1);
	LD	HL,(IX+-21)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	DEC	HL
	PUSH	HL
	LD	HL,(IX+-3)
	LD	IY,(HL)
	LEA	BC,IY+-13
	PUSH	BC
	LD	BC,_sparkle_data
	PUSH	BC
	CALL	_gfx_RLETSprite
	POP	BC
	POP	BC
	POP	BC
;  434	
;  435	                        coinX[i] = 1020;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	BC,1020
	LD	(HL),BC
;  436	                        ++monies;
	LD	A,(_monies+3)
	LD	E,A
	LD	A,1
	LD	HL,(_monies)
	CALL	__ladd_b
	LD	(_monies),HL
	LD	A,E
	LD	(_monies+3),A
;  437	                    } else {
	JR	L_110
L_108:
;  438	                        gfx_TransparentSprite(coin_tiles[(coinAnimate[i]/10)], (coinX[i]-12), coinY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinAnimate
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+-33)
	LD	IY,(IY)
	ADD	HL,BC
	LD	BC,_coin_tiles_data
	ADD	HL,BC
	LEA	BC,IY+-12
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  439	
;  440	                        if (coinAnimate[i] < 38)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinAnimate
	ADD	HL,BC
	LD	(IX+-12),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,38
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_106
;  441	                        {
;  442	                            coinAnimate[i] += 2;
	LD	HL,(IX+-12)
	LD	A,(HL)
	INC	A
	INC	A
	LD	HL,(IX+-12)
	LD	(HL),A
;  443	                        } else {
	JR	L_110
L_106:
;  444	                            coinAnimate[i] = 0;
	LD	HL,(IX+-12)
	LD	(HL),0
;  445	                        }
;  446	                    }
;  447	                }
L_110:
;  448	
;  449	                coinX[i] -= scrollSpeed;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	(IX+-57),HL
	LD	A,(_scrollSpeed)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-57)
	LD	HL,(HL)
	LD	IY,(IX+-57)
	OR	A,A
	SBC	HL,BC
	LD	(IY),HL
;  450	            }
;  451	        }
L_113:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_114:
	LD	A,(_coinFormation)
	UEXT	HL
	LD	L,A
	LD	BC,_coin_max
	ADD	HL,BC
	LD	A,(_i)
	CP	A,(HL)
	JR	C,L_112
;  452	
;  453	        //bit that calculates zappers 'n stuff:
;  454	        for (i = 0; i < MaxZappers; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_133
L_131:
;  455	        {
;  456	            //drawing the zapper beams:
;  457	            if (zapperX[i] < 1000)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,1000
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_132
;  458	            {
;  459	                for (i_the_sequel = 0; i_the_sequel < zapperLength[i]; ++i_the_sequel)
	XOR	A,A
	LD	(_i_the_sequel),A
	JR	L_118
L_116:
;  460	                {
;  461	                    gfx_TransparentSprite(beam, zapperX[i]-14, zapperY[i]+16+(i_the_sequel*10));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_i_the_sequel)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LEA	BC,IY+16
	ADD	HL,BC
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+-14
	PUSH	BC
	LD	BC,_beam_data
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
	LD	A,(_i_the_sequel)
	INC	A
	LD	(_i_the_sequel),A
;  462	                }
L_118:
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(_i_the_sequel)
	CP	A,(HL)
	JR	C,L_116
;  463	
;  464	                //draw zapper pairs and beams with distance of zapperLength between them:
;  465	                if (zapperX[i] < 336)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,336
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_129
;  466	                {
;  467	                    randVar = randInt(0,1);
	CALL	_random
	LD	A,L
	AND	A,1
	LD	(_randVar),A
;  468	                    randVar1 = randInt(0,1);
	CALL	_random
	LD	A,L
	AND	A,1
	LD	(_randVar1),A
;  469	
;  470	                    gfx_TransparentSprite(electric_animation[randVar+2+(randVar1*4)], zapperX[i]-25, zapperY[i]-7);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LEA	BC,IY+-7
	PUSH	BC
	LD	IY,HL
	LD	A,(_randVar1)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	A,(_randVar)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	INC	BC
	INC	BC
	LD	HL,DE
	ADD	HL,BC
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LEA	BC,IY+-25
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  471	                    gfx_TransparentSprite(electric_animation[randVar], zapperX[i]-25,  zapperY[i]+7+(zapperLength[i]*10));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LEA	BC,IY+7
	ADD	HL,BC
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LD	A,(_randVar)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LEA	BC,IY+-25
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  472	
;  473	                    gfx_TransparentSprite(zapper_tiles_flipped[zapperAnimate[i]/10], zapperX[i]-18, zapperY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperAnimate
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapper_tiles_flipped
	ADD	HL,BC
	LEA	BC,IY+-18
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  474	                    gfx_TransparentSprite(zapper_tiles[zapperAnimate[i]/10], zapperX[i]-18, zapperY[i]+14+(zapperLength[i]*10));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LEA	BC,IY+14
	ADD	HL,BC
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperAnimate
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapper_tiles_data
	ADD	HL,BC
	LEA	BC,IY+-18
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  475	
;  476	                    if (zapperAnimate[i] < 28)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperAnimate
	ADD	HL,BC
	LD	(IX+-15),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,28
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_120
;  477	                    {
;  478	                        zapperAnimate[i] += 2;
	LD	HL,(IX+-15)
	LD	A,(HL)
	INC	A
	INC	A
	LD	HL,(IX+-15)
	LD	(HL),A
;  479	                    } else {
	JR	L_126
L_120:
;  480	                        zapperAnimate[i] = 0;
	LD	HL,(IX+-15)
	LD	(HL),0
;  481	                    }
L_126:
;  482	
;  483	                    //collision for zappers:
;  484	                    if ((health > 0) && (gfx_CheckRectangleHotspot(avatarX+6, zapperY[i]+2, 18, (zapperLength[i]*10)+30, zapperX[i]-14, avatarY, 10, 50)))
	XOR	A,A
	LD	HL,_health
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_129
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	(IX+-27),HL
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,(IX+-27)
	LD	BC,(IY)
	LD	IY,HL
	LEA	DE,IY+24
	CALL	__stoiu
	LD	IY,HL
	LEA	HL,IY+-14
	OR	A,A
	SBC	HL,DE
	CALL	__setflag
	JP	P,L_129
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,(IX+-27)
	LD	BC,(IY)
	LD	IY,HL
	CALL	__stoiu
	LEA	DE,IY+6
	LD	BC,HL
	DEC	BC
	DEC	BC
	DEC	BC
	DEC	BC
	OR	A,A
	LD	HL,DE
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_129
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LEA	BC,IY+2
	LD	(IX+-30),BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LD	IY,HL
	LEA	HL,IY+30
	LD	BC,(IX+-30)
	ADD	HL,BC
	LD	BC,HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	OR	A,A
	SBC	HL,BC
	JR	NC,L_129
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+50
	LD	HL,(IX+-30)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_129
;  485	                    {
;  486	                        --health;
	LD	A,(_health)
	DEC	A
	LD	(_health),A
;  487	                    }
;  488	                }
L_129:
;  489	
;  490	                zapperX[i] -= scrollSpeed;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	(IX+-60),HL
	LD	HL,(HL)
	LD	A,(_scrollSpeed)
	OR	A,A
	LD	C,A
	LD	B,0
	SBC.SIS	HL,BC
	LD	BC,HL
	LD	HL,(IX+-60)
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  491	            }
;  492	        }
L_132:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_133:
	LD	A,(_i)
	CP	A,3
	JR	C,L_131
;  493	
;  494	        //bit that draws and calculates the missiles 'o death:
;  495	        for (i = 0; i < MaxMissiles; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_155
L_153:
;  496	        {
;  497	            if (missileX[i] < 6001)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_missileX
	ADD	HL,BC
	LD	(IX+-9),HL
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,6001
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_154
;  498	            {
;  499	                if (missileX[i] < 366)
	LD	HL,(IX+-9)
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,366
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_147
;  500	                {
;  501	                    gfx_TransparentSprite(missile, missileX[i]-46, missileY[i]-18);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_missileY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+-18
	PUSH	BC
	LD	HL,(IX+-9)
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+-46
	PUSH	BC
	LD	BC,_missile_data
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  502	
;  503	                    if ((health > 0) && (gfx_CheckRectangleHotspot(missileX[i]-45, avatarY, 19, 40, avatarX+6, missileY[i]-5, 18, 12)))
	XOR	A,A
	LD	HL,_health
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_150
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_missileX
	ADD	HL,BC
	LD	(IX+-36),HL
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,(IX+-36)
	LD	BC,(IY)
	LD	IY,HL
	LEA	DE,IY+6
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+-26
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_150
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,(IX+-36)
	LD	BC,(IY)
	LD	IY,HL
	CALL	__stoiu
	LEA	BC,IY+24
	LD	IY,HL
	LEA	HL,IY+-45
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_150
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_missileY
	ADD	HL,BC
	LD	(IX+-39),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LEA	BC,IY+-5
	LD	IY,HL
	LEA	DE,IY+40
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	CALL	__setflag
	JP	P,L_150
	LD	HL,(IX+-39)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	OR	A,A
	LEA	BC,IY+7
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_150
;  504	                    {
;  505	                        --health;
	LD	A,(_health)
	DEC	A
	LD	(_health),A
;  506	                    }
;  507	
;  508	                } else if (missileX[i] < 641) {
	JR	L_150
L_147:
	LD	HL,(IX+-9)
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,641
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_145
;  509	
;  510	                    //AW CRAP HERE COME DAT BOI!
;  511	                    gfx_TransparentSprite(missileIncoming_tiles[missileAnimate/3], 281+randInt(-1,1), missileY[i]-16+randInt(-1,1));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_missileY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+-16
	LD	(IX+-75),BC	; spill
	CALL	_random
	LD	BC,3
	CALL	__iremu
	LD	BC,HL
	DEC	BC
	LD	(IX+-72),BC	; spill
	LD	HL,(IX+-75)
	LD	BC,(IX+-72)	; unspill
	ADD	HL,BC
	PUSH	HL
	CALL	_random
	LD	BC,3
	CALL	__iremu
	LD	BC,280
	LD	A,(_missileAnimate)
	LD	D,A
	ADD	HL,BC
	PUSH	HL
	SEXT	HL
	LD	L,D
	LD	BC,3
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_missileIncoming_tiles_data
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  512	
;  513	                } else if (missileX[i] < 1467) {
	JR	L_150
L_145:
	LD	HL,(IX+-9)
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,1467
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_150
;  514	
;  515	                    //plenty of time to dodge (at the beginning at least)
;  516	                    gfx_TransparentSprite(missileWarning_tiles[missileAnimate/2], 293, missileY[i]-11);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_missileY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,(_missileAnimate)
	LD	B,A
	LD	IY,HL
	SEXT	HL
	LD	L,B
	LD	BC,2
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LEA	BC,IY+-11
	PUSH	BC
	LD	BC,_missileWarning_tiles_data
	ADD	HL,BC
	LD	BC,293
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  517	
;  518	                    //tracking on avatar
;  519	                    if (missileY[i] < (avatarY + 20))
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_missileY
	ADD	HL,BC
	LD	(IX+-6),HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LD	IY,(IX+-6)
	LD	A,(IY)
	LD	IY,HL
	UEXT	HL
	LD	L,A
	OR	A,A
	LEA	BC,IY+20
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_142
;  520	                    {
;  521	                        missileY[i] += 2;
	LD	HL,(IX+-6)
	LD	A,(HL)
	INC	A
	INC	A
	LD	HL,(IX+-6)
	LD	(HL),A
;  522	                    } else if (missileY[i] > (avatarY + 21)) {
	JR	L_150
L_142:
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LD	IY,(IX+-6)
	LD	A,(IY)
	LD	IY,HL
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LEA	HL,IY+21
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_150
;  523	                        missileY[i] -= 2;
	LD	HL,(IX+-6)
	LD	A,(HL)
	DEC	A
	DEC	A
	LD	HL,(IX+-6)
	LD	(HL),A
;  524	                    }
;  525	                }
L_150:
;  526	
;  527	                //make missileAnimate go up and down between 0 and 5 by toggling MAvalue:
;  528	                if ((missileAnimate < 1) || (missileAnimate > 4))
	LD	A,(_missileAnimate)
	CP	A,1
	CALL	__setflag
	JP	M,L_149
	LD	A,4
	LD	HL,_missileAnimate
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_151
L_149:
;  529	                {
;  530	                    MAvalue *= -1;
	LD	A,(_MAvalue)
	NEG	
	LD	(_MAvalue),A
;  531	                }
L_151:
;  532	                missileAnimate += MAvalue;
	LD	BC,(_MAvalue)
	LD	A,(_missileAnimate)
	ADD	A,C
	LD	(_missileAnimate),A
;  533	
;  534	                //missiles travel by 6 pixels each frame. It was surprisingly tedious to figure that out
;  535	                //from frame-by-frame reviewing of missiles; however, it's too slow on the calc.
;  536	                missileX[i] -= scrollSpeed + 8;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_missileX
	ADD	HL,BC
	LD	(IX+-63),HL
	LD	A,(_scrollSpeed)
	LD	C,A
	LD	B,0
	LD	IY,BC
	LD	HL,(IX+-63)
	LD	HL,(HL)
	LEA	BC,IY+8
	OR	A,A
	SBC.SIS	HL,BC
	LD	BC,HL
	LD	HL,(IX+-63)
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  537	            }
;  538	        }
L_154:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_155:
	LD	A,(_i)
	CP	A,1
	JR	C,L_153
;  539	
;  540	        //move lasers into play when needed:
;  541	        if ((laserX < 20) && (deadLasers < laserMax[laserFormation]))
	LD	A,(_laserX)
	CP	A,20
	CALL	__setflag
	JP	P,L_161
	LD	A,(_laserFormation)
	UEXT	HL
	LD	L,A
	LD	BC,_laserMax
	ADD	HL,BC
	LD	A,(_deadLasers)
	CP	A,(HL)
	JR	NC,L_161
;  542	        {
;  543	            ++laserX;
	LD	A,(_laserX)
	INC	A
	LD	(_laserX),A
;  544	        } else if((deadLasers >= laserMax[laserFormation]) && (laserX > 0)) {
	JR	L_188
L_161:
	LD	A,(_laserFormation)
	UEXT	HL
	LD	L,A
	LD	BC,_laserMax
	ADD	HL,BC
	LD	A,(_deadLasers)
	CP	A,(HL)
	JR	C,L_188
	XOR	A,A
	LD	HL,_laserX
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_188
;  545	            --laserX;
	LD	A,(_laserX)
	DEC	A
	LD	(_laserX),A
;  546	        }
L_188:
;  547	
;  548	        //bit for lasers, lots of moving parts:
;  549	        for(i = 0; i < laserMax[laserFormation]; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_187
L_185:
;  550	        {
;  551	            if (laserX > 0)
	XOR	A,A
	LD	HL,_laserX
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_186
;  552	            {
;  553	                //reset the laser animations:
;  554	                if ((laserX < 20) && (deadLasers < laserMax[laserFormation]))
	LD	A,(_laserX)
	CP	A,20
	CALL	__setflag
	JP	P,L_180
	LD	BC,(IX+-24)
	LD	(IX+-45),BC
	LD	HL,(IX+-24)
	LD	A,(_deadLasers)
	CP	A,(HL)
	JR	NC,L_180
;  555	                {
;  556	                    laserAnimate = 0;
	XOR	A,A
	LD	(_laserAnimate),A
;  557	
;  558	                    //draw an inactive laser:
;  559	                    gfx_TransparentSprite(powering_tiles[0], laserX-19, laserY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_laserX)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	IY,HL
	LEA	BC,IY+-19
	PUSH	BC
	LD	BC,(_powering_tiles_data)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  560	                    gfx_TransparentSprite(powering_tiles[0], 320 - laserX, laserY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_laserX)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,320
	OR	A,A
	SBC	HL,BC
	PUSH	HL
	LD	BC,(_powering_tiles_data)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  561	
;  562	                } else {
	JR	L_183
L_180:
;  563	                    //if they are finished, finish the animation sequence and hide them again:
;  564	                    if(deadLasers >= laserMax[laserFormation])
	LD	HL,(IX+-45)
	LD	A,(_deadLasers)
	CP	A,(HL)
	JR	C,L_178
;  565	                    {
;  566	                        laserAnimate = 0;
	XOR	A,A
	LD	(_laserAnimate),A
;  567	
;  568	                    //if they aren't dead and have moved, run through their animations and attacks:
;  569	                    } else {
	JR	L_183
L_178:
;  570	
;  571	                        //check to see if the half-life ended:
;  572	                        if(laserLifetime[i] < 1)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_laserLifetime
	ADD	HL,BC
	LD	(IX+-18),HL
	OR	A,A
	LD	HL,(HL)
	LD	BC,1
	SBC	HL,BC
	JR	NC,L_175
;  573	                        {
;  574	                            ++deadLasers;
	LD	A,(_deadLasers)
	INC	A
	LD	(_deadLasers),A
;  575	
;  576	                        } else if(laserLifetime[i] < 9) {
	JR	L_176
L_175:
	LD	HL,(IX+-18)
	LD	HL,(HL)
	LD	BC,9
	OR	A,A
	SBC	HL,BC
	JR	NC,L_173
;  577	
;  578	                            //lasers running out of juice:
;  579	                            gfx_TransparentSprite(shutdown_tiles[laserAnimate/3], 5, laserY[i]-16);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,(_laserAnimate)
	LD	B,A
	LD	IY,HL
	SEXT	HL
	LD	L,B
	LD	BC,3
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LEA	BC,IY+-16
	PUSH	BC
	LD	BC,_shutdown_tiles_data
	ADD	HL,BC
	LD	BC,5
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  580	                            gfx_TransparentSprite(shutdown_tiles_flipped[laserAnimate/3], 285, laserY[i]-16);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,(_laserAnimate)
	LD	B,A
	LD	IY,HL
	SEXT	HL
	LD	L,B
	LD	BC,3
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LEA	BC,IY+-16
	PUSH	BC
	LD	BC,_shutdown_tiles_flipped
	ADD	HL,BC
	LD	BC,285
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  581	
;  582	                            gfx_RLETSprite(laser_tiles[(laserAnimate/3)+1], 35, laserY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_laserAnimate)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,3
	CALL	__idivs
	INC	HL
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_laser_tiles_data
	ADD	HL,BC
	LD	BC,35
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_RLETSprite
	POP	BC
	POP	BC
	POP	BC
;  583	
;  584	                        } else if(laserLifetime[i] < 59) {
	JR	L_176
L_173:
	LD	HL,(IX+-18)
	LD	HL,(HL)
	LD	BC,59
	OR	A,A
	SBC	HL,BC
	JR	NC,L_171
;  585	                            //firing lasers:
;  586	                            gfx_TransparentSprite(firing_tiles[laserAnimate/3], 5, laserY[i]-11);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,(_laserAnimate)
	LD	B,A
	LD	IY,HL
	SEXT	HL
	LD	L,B
	LD	BC,3
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LEA	BC,IY+-11
	PUSH	BC
	LD	BC,_firing_tiles_data
	ADD	HL,BC
	LD	BC,5
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  587	                            gfx_TransparentSprite(firing_tiles_flipped[laserAnimate/3], 285, laserY[i]-11);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,(_laserAnimate)
	LD	B,A
	LD	IY,HL
	SEXT	HL
	LD	L,B
	LD	BC,3
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LEA	BC,IY+-11
	PUSH	BC
	LD	BC,_firing_tiles_flipped
	ADD	HL,BC
	LD	BC,285
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  588	
;  589	                            gfx_RLETSprite(laser_tiles[0], 35, laserY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	BC,35
	PUSH	BC
	LD	BC,(_laser_tiles_data)
	PUSH	BC
	CALL	_gfx_RLETSprite
	POP	BC
	POP	BC
	POP	BC
;  590	
;  591	                            //hitbox for damage. 5 pixel leeway above and below:
;  592	                            if((health > 0) && Yspot(avatarY, 35, laserY[i], 10))
	XOR	A,A
	LD	HL,_health
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_168
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	(IX+-51),HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LD	IY,(IX+-51)
	LD	A,(IY)
	LD	IY,HL
	UEXT	HL
	LD	L,A
	OR	A,A
	LEA	BC,IY+35
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_168
	LD	HL,(IX+-51)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	OR	A,A
	LEA	BC,IY+10
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_168
;  593	                            {
;  594	                                --health;
	LD	A,(_health)
	DEC	A
	LD	(_health),A
;  595	                            }
L_168:
;  596	
;  597	                            //makes sure the animations play correctly, I don't have time to fix math today:
;  598	                            if (laserLifetime[i] == 9) laserAnimate = 0;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_laserLifetime
	ADD	HL,BC
	LD	HL,(HL)
	OR	A,A
	LD	BC,9
	SBC	HL,BC
	JR	NZ,L_176
	XOR	A,A
	LD	(_laserAnimate),A
;  599	
;  600	                        } else if (laserLifetime[i] < 109) {
	JR	L_176
L_171:
	LD	HL,(IX+-18)
	LD	HL,(HL)
	LD	BC,109
	OR	A,A
	SBC	HL,BC
	JR	NC,L_176
;  601	
;  602	                            //the simplest drawing code in this hot mess, for powering up:
;  603	                            gfx_SetColor(4);
	LD	BC,4
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  604	
;  605	                            gfx_Line(20, laserY[i]+7, 300, laserY[i]+7);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	(IX+-66),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+7
	LD	DE,BC
	PUSH	DE
	LD	DE,300
	PUSH	DE
	PUSH	BC
	LD	BC,20
	PUSH	BC
	CALL	_gfx_Line
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  606	
;  607	                            gfx_Circle(11, laserY[i]+7, 7 + ((laserLifetime[i]-50)/4));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_laserLifetime
	ADD	HL,BC
	LD	IY,(HL)
	LEA	HL,IY+-50
	LD	A,2
	CALL	__ishru_b
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LEA	BC,IY+7
	PUSH	BC
	LD	IY,HL
	LEA	BC,IY+7
	PUSH	BC
	LD	BC,11
	PUSH	BC
	CALL	_gfx_Circle
	POP	BC
	POP	BC
	POP	BC
;  608	                            //gfx_Circle(11, laserY[i]+7, 6 + ((laserLifetime[i]-50)/4));
;  609	
;  610	                            gfx_Circle(308, laserY[i]+7, 7 + ((laserLifetime[i]-50)/4));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_laserLifetime
	ADD	HL,BC
	LD	IY,(HL)
	LEA	HL,IY+-50
	LD	A,2
	CALL	__ishru_b
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LEA	BC,IY+7
	PUSH	BC
	LD	IY,HL
	LEA	BC,IY+7
	PUSH	BC
	LD	BC,308
	PUSH	BC
	CALL	_gfx_Circle
	POP	BC
	POP	BC
	POP	BC
;  611	                            //gfx_Circle(308, laserY[i]+7, 8 + ((laserLifetime[i]-50)/4));
;  612	                        }
L_176:
;  613	
;  614	                        //update the laser's timer:
;  615	                        --laserLifetime[i];
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_laserLifetime
	ADD	HL,BC
	LD	(IX+-69),HL
	LD	IY,(HL)
	LEA	BC,IY+-1
	LD	HL,(IX+-69)
	LD	(HL),BC
;  616	                    }
;  617	                }
L_183:
;  618	
;  619	                if (laserLifetime[i] < 109)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_laserLifetime
	ADD	HL,BC
	LD	HL,(HL)
	OR	A,A
	LD	BC,109
	SBC	HL,BC
	JR	NC,L_182
;  620	                {
;  621	                    gfx_TransparentSprite(powering_tiles[(laserAnimate/3)+1], laserX-19, laserY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_laserX)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	A,(_laserAnimate)
	LD	B,A
	LD	IY,HL
	SEXT	HL
	LD	L,B
	LD	BC,3
	CALL	__idivs
	INC	HL
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_powering_tiles_data
	ADD	HL,BC
	LEA	BC,IY+-19
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  622	                    gfx_TransparentSprite(powering_tiles_flipped[(laserAnimate/3)+1], 320 - laserX, laserY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_laserX)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,320
	OR	A,A
	LD	A,(_laserAnimate)
	LD	D,A
	SBC	HL,BC
	PUSH	HL
	SEXT	HL
	LD	L,D
	LD	BC,3
	CALL	__idivs
	INC	HL
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_powering_tiles_flipped
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  623	                } else {
	JR	L_186
L_182:
;  624	                    gfx_TransparentSprite(powering_tiles[0], laserX-19, laserY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_laserX)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	IY,HL
	LEA	BC,IY+-19
	PUSH	BC
	LD	BC,(_powering_tiles_data)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  625	                    gfx_TransparentSprite(powering_tiles_flipped[0], 320 - laserX, laserY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_laserX)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,320
	OR	A,A
	SBC	HL,BC
	PUSH	HL
	LD	BC,(_powering_tiles_flipped)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  626	                }
;  627	            }
;  628	        }
L_186:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_187:
	LD	A,(_laserFormation)
	UEXT	HL
	LD	L,A
	LD	BC,_laserMax
	ADD	HL,BC
	LD	(IX+-24),HL
	LD	(IX+-45),HL
	LD	HL,(IX+-24)
	LD	A,(_i)
	CP	A,(HL)
	JR	C,L_185
;  629	
;  630	        if (laserAnimate < 8)
	LD	A,(_laserAnimate)
	CP	A,8
	CALL	__setflag
	JP	P,L_190
;  631	        {
;  632	            ++laserAnimate;
	LD	A,(_laserAnimate)
	INC	A
	LD	(_laserAnimate),A
;  633	        } else {
	JR	L_192
L_190:
;  634	            laserAnimate = 0;
	XOR	A,A
	LD	(_laserAnimate),A
;  635	        }
L_192:
;  636	
;  637	        //FPS counter:
;  638	        frameTime = (32768 / timer_1_Counter);
	LD	HL,32768
	LD	E,0
	LD	BC,(15859712)
	LD	A,(15859715)
	CALL	__ldivu
	LD	BC,HL
	LD	A,C
	LD	(_frameTime),A
;  639	
;  640	        if (frameTime > 25)
	LD	A,25
	LD	HL,_frameTime
	CP	A,(HL)
	JR	NC,L_194
;  641	        {
;  642	            delay(40 - (1000/frameTime));
	LD	A,(_frameTime)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,1000
	CALL	__idivs
	LD	BC,HL
	LD.LIS	HL,40
	OR	A,A
	SBC.SIS	HL,BC
	PUSH	HL
	CALL	_delay
	POP	BC
;  643	        }
L_194:
;  644	
;  645	        timer_1_Counter = 0;
;  646	
;  647	        //gold coin color for money counter:
;  648	        gfx_SetTextFGColor(3);
	LD	BC,3
	PUSH	BC
	LD	BC,0
	LD	(15859712),BC
	XOR	A,A
	LD	(15859715),A
	CALL	_gfx_SetTextFGColor
	POP	BC
;  649	
;  650	        gfx_SetTextScale(1, 1);
	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_gfx_SetTextScale
	POP	BC
	POP	BC
;  651	        gfx_SetTextXY(10, 30);
	LD	BC,30
	PUSH	BC
	LD	BC,10
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  652	        gfx_PrintInt(monies, 4);
	LD	BC,4
	PUSH	BC
	LD	BC,(_monies)
	PUSH	BC
	CALL	_gfx_PrintInt
	POP	BC
	POP	BC
;  653	
;  654	        //distance and FPS counter are gray:
;  655	        gfx_SetTextFGColor(2);
	LD	BC,2
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;  656	
;  657	        gfx_SetTextXY(280, 10);
	LD	BC,10
	PUSH	BC
	LD	BC,280
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  658	        gfx_PrintInt(frameTime, 1);
	LD	A,(_frameTime)
	UEXT	HL
	LD	BC,1
	PUSH	BC
	LD	L,A
	PUSH	HL
	LD	(IX+-88),A
	CALL	_gfx_PrintInt
	LD	A,(IX+-88)
	POP	BC
	POP	BC
;  659	
;  660	        gfx_SetTextScale(2,2);
	LD	BC,2
	PUSH	BC
	PUSH	BC
	LD	(IX+-88),A
	CALL	_gfx_SetTextScale
	LD	A,(IX+-88)
	POP	BC
	POP	BC
;  661	        gfx_SetTextXY(10, 10);
	LD	BC,10
	PUSH	BC
	PUSH	BC
	LD	(IX+-88),A
	CALL	_gfx_SetTextXY
	LD	A,(IX+-88)
	POP	BC
	POP	BC
;  662	        gfx_PrintInt((distance += scrollSpeed)/15, 4);
	UEXT	HL
	LD	A,(_scrollSpeed)
	LD	L,A
	LD	A,(_distance+3)
	LD	E,A
	LD	BC,HL
	LD	A,H
	LD	HL,(_distance)
	CALL	__ladd
	LD	(_distance),HL
	LD	A,E
	LD	(_distance+3),A
	LD	E,A
	XOR	A,A
	LD	BC,15
	LD	(IX+-84),HL	; spill
	LD	HL,4
	LD	(IX+-87),HL	; spill
	LD	HL,(IX+-84)	; unspill
	LD	(IX+-84),HL	; spill
	LD	HL,(IX+-87)	; unspill
	PUSH	HL
	LD	HL,(IX+-84)	; unspill
	CALL	__ldivu
	PUSH	HL
	CALL	_gfx_PrintInt
	POP	BC
	POP	BC
;  663	
;  664	        gfx_SwapDraw();
	CALL	_gfx_SwapDraw
;  665	
;  666	    } while (!(kb_Data[6] & kb_Clear) && (health > 0));
	LD	A,(16056348)
	AND	A,64
	JR	NZ,L_206
	XOR	A,A
	LD	HL,_health
	CP	A,(HL)
	JP	M,L_196
L_206:
;  667	
;  668	    if (health < 1)
	LD	A,(_health)
	CP	A,1
	CALL	__setflag
	JP	P,L_207
;  669	    {
;  670	        gfx_FillScreen(1);
	LD	BC,1
	PUSH	BC
	CALL	_gfx_FillScreen
	POP	BC
;  671	        gfx_SetTextScale(4, 4);
	LD	BC,4
	PUSH	BC
	PUSH	BC
	CALL	_gfx_SetTextScale
	POP	BC
	POP	BC
;  672	        gfx_PrintStringXY("U is ded lol.", 15, 100);
	LD	BC,100
	PUSH	BC
	LD	BC,15
	PUSH	BC
	LD	BC,L__96
	PUSH	BC
	CALL	_gfx_PrintStringXY
	POP	BC
	POP	BC
	POP	BC
;  673	        gfx_SwapDraw();
	CALL	_gfx_SwapDraw
;  674	
;  675	        while (kb_AnyKey());
L_199:
	CALL	_kb_AnyKey
	OR	A,A
	JR	NZ,L_199
;  676	        while (!kb_AnyKey());
L_201:
	CALL	_kb_AnyKey
	OR	A,A
	JR	Z,L_201
;  677	
;  678	        if (kb_Data[6] != kb_Clear)
	LD	A,(16056348)
	CP	A,64
	JR	NZ,L_37
;  679	        {
;  680	            goto GAMESTART;
;  681	        }
;  682	    }
L_207:
;  683	
;  684	    //stop libraries, not doing so causes "interesting" results
;  685	    gfx_End();
	CALL	_gfx_End
;  686	
;  687	    ti_CloseAll();
	CALL	_ti_CloseAll
;  688	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_ti_CloseAll                        IMPORT  -----   function
;_gfx_End                            IMPORT  -----   function
;_kb_AnyKey                          IMPORT  -----   function
;_gfx_PrintStringXY                  IMPORT  -----   function
;_gfx_FillScreen                     IMPORT  -----   function
;_gfx_SwapDraw                       IMPORT  -----   function
;_gfx_PrintInt                       IMPORT  -----   function
;_gfx_SetTextXY                      IMPORT  -----   function
;_gfx_SetTextScale                   IMPORT  -----   function
;_gfx_SetTextFGColor                 IMPORT  -----   function
;_delay                              IMPORT  -----   function
;_frameTime                          STATIC      1   variable
;_gfx_Circle                         IMPORT  -----   function
;_gfx_Line                           IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_laser_tiles_data                   IMPORT     12   variable
;_laserAnimate                       STATIC      1   variable
;_MAvalue                            STATIC      1   variable
;_missileWarning_tiles_data          IMPORT      9   variable
;_missileAnimate                     STATIC      1   variable
;_missileIncoming_tiles_data         IMPORT      6   variable
;_missile_data                       IMPORT   1658   variable
;_zapperAnimate                      STATIC      3   variable
;_randVar1                           STATIC      1   variable
;_beam_data                          IMPORT    102   variable
;_i_the_sequel                       STATIC      1   variable
;_coin_max                           IMPORT      6   variable
;_coin_tiles_data                    IMPORT     12   variable
;_gfx_TransparentSprite              IMPORT  -----   function
;_sparkle_data                       IMPORT    147   variable
;_gfx_RLETSprite                     IMPORT  -----   function
;_nozzle_data                        IMPORT     16   variable
;_exhaust_tiles_data                 IMPORT     18   variable
;_avatar_tiles_data                  IMPORT     12   variable
;_abs                                IMPORT  -----   function
;_gfx_TransparentSprite_NoClip       IMPORT  -----   function
;_background_data                    IMPORT  46082   variable
;_gfx_Sprite                         IMPORT  -----   function
;_avatarAnimate                      STATIC      1   variable
;_displacement                       STATIC      1   variable
;_zapperY                            STATIC      9   variable
;_zapperLength                       STATIC      3   variable
;_zapperX                            STATIC      6   variable
;_missileDelay                       STATIC      1   variable
;_missileY                           STATIC      1   variable
;_missileX                           STATIC      2   variable
;_coinAnimate                        STATIC     30   variable
;_coinY                              STATIC     30   variable
;_cty                                IMPORT    180   variable
;_coinX                              STATIC     90   variable
;_ctx                                IMPORT    540   variable
;_coinFormation                      STATIC      1   variable
;_randVar                            STATIC      1   variable
;_laserX                             STATIC      1   variable
;_laserMax                           IMPORT      3   variable
;_laserLifetime                      STATIC     21   variable
;_halfLife                           IMPORT     21   variable
;_laserY                             STATIC      7   variable
;_lsrY                               IMPORT     21   variable
;_laserFormation                     STATIC      1   variable
;_randObject                         STATIC      1   variable
;_random                             IMPORT  -----   function
;_backgroundScroll                   STATIC      3   variable
;_kb_Scan                            IMPORT  -----   function
;_deadLasers                         STATIC      1   variable
;_monies                             STATIC      4   variable
;_distance                           STATIC      4   variable
;_spawnDelay                         STATIC      3   variable
;_health                             STATIC      1   variable
;_flightTime                         STATIC      1   variable
;_holdTime                           STATIC      1   variable
;_avatarY                            STATIC      1   variable
;_avatarX                            STATIC      2   variable
;_scrollSpeed                        STATIC      1   variable
;_gfx_SetTransparentColor            IMPORT  -----   function
;_jetpack_palette                    IMPORT    512   variable
;_gfx_SetPalette                     IMPORT  -----   function
;_gfx_SetDraw                        IMPORT  -----   function
;_gfx_Begin                          IMPORT  -----   function
;_shutdown_tiles_data                IMPORT      9   variable
;_shutdown_tiles_flipped             STATIC      9   variable
;_firing_tiles_data                  IMPORT      9   variable
;_firing_tiles_flipped               STATIC      9   variable
;_powering_tiles_data                IMPORT     12   variable
;_powering_tiles_flipped             STATIC     12   variable
;_gfx_RotateSpriteHalf               IMPORT  -----   function
;_gfx_FlipSpriteY                    IMPORT  -----   function
;_electric_tiles_data                IMPORT      6   variable
;_electric_animation                 STATIC     24   variable
;_zapper_tiles_data                  IMPORT      9   variable
;_gfx_FlipSpriteX                    IMPORT  -----   function
;_zapper_tiles_flipped               STATIC      9   variable
;_malloc                             IMPORT  -----   function
;_gfx_AllocSprite                    IMPORT  -----   function
;_i                                  STATIC      1   variable
;G_0                                  IX-54      3   variable
;G_29                                 IX-51      3   variable
;G_2                                  IX-48      3   variable
;G_26                                 IX-45      3   variable
;G_1                                  IX-42      3   variable
;G_19                                 IX-39      3   variable
;G_18                                 IX-36      3   variable
;G_9                                  IX-33      3   variable
;G_15                                 IX-30      3   variable
;G_14                                 IX-27      3   variable
;G_25                                 IX-24      3   variable
;G_6                                  IX-21      3   variable
;G_27                                 IX-18      3   variable
;G_12                                 IX-15      3   variable
;G_10                                 IX-12      3   variable
;G_16                                  IX-9      3   variable
;G_22                                  IX-6      3   variable
;G_3                                   IX-3      3   variable


; Stack Frame Size: 94 (bytes)
;       Spill Code: -1 (instruction)


	SEGMENT STRSECT
L__96:
	DB	"U is ded lol."
	DB	0
	XREF _laser_tiles_data:ROM
	XREF _shutdown_tiles_data:ROM
	XREF _powering_tiles_data:ROM
	XREF _firing_tiles_data:ROM
	XREF _missileIncoming_tiles_data:ROM
	XREF _missileWarning_tiles_data:ROM
	XREF _electric_tiles_data:ROM
	XREF _zapper_tiles_data:ROM
	XREF _coin_tiles_data:ROM
	XREF _exhaust_tiles_data:ROM
	XREF _avatar_tiles_data:ROM
	XREF _sparkle_data:ROM
	XREF _missile_data:ROM
	XREF _beam_data:ROM
	XREF _nozzle_data:ROM
	XREF _background_data:ROM
	XREF _jetpack_palette:ROM
	XREF _kb_AnyKey:ROM
	XREF _kb_Scan:ROM
	XREF _gfx_RLETSprite:ROM
	XREF _gfx_RotateSpriteHalf:ROM
	XREF _gfx_FlipSpriteY:ROM
	XREF _gfx_FlipSpriteX:ROM
	XREF _gfx_TransparentSprite_NoClip:ROM
	XREF _gfx_TransparentSprite:ROM
	XREF _gfx_Sprite:ROM
	XREF _gfx_SetTextFGColor:ROM
	XREF _gfx_SetTextXY:ROM
	XREF _gfx_PrintStringXY:ROM
	XREF _gfx_PrintInt:ROM
	XREF _gfx_SetTextScale:ROM
	XREF _gfx_SwapDraw:ROM
	XREF _gfx_SetDraw:ROM
	XREF _gfx_Circle:ROM
	XREF _gfx_Line:ROM
	XREF _gfx_FillScreen:ROM
	XREF _gfx_SetPalette:ROM
	XREF _gfx_SetTransparentColor:ROM
	XREF _gfx_SetColor:ROM
	XREF _gfx_End:ROM
	XREF _gfx_Begin:ROM
	XREF _gfx_AllocSprite:ROM
	XREF _ti_CloseAll:ROM
	XREF _abs:ROM
	XREF _malloc:ROM
	XREF _delay:ROM
	XREF _random:ROM
	XREF __ladd:ROM
	XREF __idivs:ROM
	XREF __imuls:ROM
	XREF __ldivu:ROM
	XREF __iremu:ROM
	XREF __stoiu:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __imul_b:ROM
	XREF __ladd_b:ROM
	XREF __ishru_b:ROM
	XDEF _main
	XDEF _delObjects
	XDEF _shutdown_tiles_flipped
	XDEF _firing_tiles_flipped
	XDEF _powering_tiles_flipped
	XDEF _electric_animation
	XDEF _zapper_tiles_flipped
	XDEF _deadLasers
	XDEF _laserFormation
	XDEF _laserAnimate
	XDEF _laserLifetime
	XDEF _laserY
	XDEF _laserX
	XDEF _MAvalue
	XDEF _missileAnimate
	XDEF _missileY
	XDEF _missileX
	XDEF _zapperAnimate
	XDEF _zapperLength
	XDEF _zapperX
	XDEF _zapperY
	XDEF _coinAnimate
	XDEF _coinFormation
	XDEF _coinY
	XDEF _coinX
	XDEF _randObject
	XDEF _randVar1
	XDEF _randVar
	XDEF _distance
	XDEF _monies
	XDEF _health
	XDEF _backgroundScroll
	XDEF _missileDelay
	XDEF _spawnDelay
	XDEF _scrollSpeed
	XDEF _holdTime
	XDEF _frameTime
	XDEF _flightTime
	XDEF _displacement
	XDEF _avatarAnimate
	XDEF _avatarY
	XDEF _avatarX
	XDEF _i_the_sequel
	XDEF _i
	XDEF _halfLife
	XDEF _lsrY
	XDEF _laserMax
	XDEF _cty
	XDEF _ctx
	XDEF _coin_max
	END
