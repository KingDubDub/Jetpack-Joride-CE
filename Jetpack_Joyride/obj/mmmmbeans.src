; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\MMMMBEANS.C"
	.assume ADL=1
	SEGMENT TEXT
_abbreviatedMax:
	DB	30
	DB	21
	DB	24
	DB	26
	DB	17
	DB	30
_ctx:
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	144
	DB	0
	DW	156
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	108
	DB	0
	DW	120
	DB	0
	DW	144
	DB	0
	DW	156
	DB	0
	DW	180
	DB	0
	DW	192
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	108
	DB	0
	DW	120
	DB	0
	DW	180
	DB	0
	DW	192
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	84
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	60
	DB	0
	DW	72
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	108
	DB	0
	DW	84
	DB	0
	DW	96
	DB	0
	DW	84
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	48
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	0
	DB	0
	DW	12
	DB	0
	DW	24
	DB	0
	DW	36
	DB	0
	DW	24
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	96
	DB	0
	DW	12
	DB	0
	DW	36
	DB	0
	DW	60
	DB	0
	DW	84
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	96
	DB	0
	DW	12
	DB	0
	DW	36
	DB	0
	DW	60
	DB	0
	DW	84
	DB	0
	DW	108
	DB	0
	DW	0
	DB	0
	DW	24
	DB	0
	DW	48
	DB	0
	DW	72
	DB	0
	DW	96
	DB	0
	DW	12
	DB	0
	DW	36
	DB	0
	DW	60
	DB	0
	DW	84
	DB	0
	DW	108
	DB	0
_cty:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	12
	DB	12
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	36
	DB	36
	DB	36
	DB	36
	DB	48
	DB	48
	DB	48
	DB	48
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	48
	DB	48
	DB	60
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	12
	DB	12
	DB	24
	DB	24
	DB	36
	DB	36
	DB	36
	DB	48
	DB	48
	DB	60
	DB	60
	DB	60
	DB	60
	DB	72
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12
	DB	12
	DB	12
	DB	12
	DB	12
	DB	24
	DB	24
	DB	24
	DB	24
	DB	24
	DB	36
	DB	36
	DB	36
	DB	36
	DB	36
	DB	48
	DB	48
	DB	48
	DB	48
	DB	48
	DB	60
	DB	60
	DB	60
	DB	60
	DB	60
	SEGMENT BSS
_i:
	DS	1
_i_the_sequel:
	DS	1
_avatarX:
	DS	2*1
_avatarY:
	DS	1
	SEGMENT DATA
_avatarAnimate:
	DB	1
_displacement:
	DB	3
_flightTime:
	DB	18
	SEGMENT BSS
_frameTime:
	DS	1
_holdTime:
	DS	1
_scrollSpeed:
	DS	1
	SEGMENT DATA
_spawnDelay:
	DW	200
	DB	0
	SEGMENT BSS
_backgroundScroll:
	DS	3
_health:
	DS	1
_monies:
	DS	4*1
_distance:
	DS	4*1
_randVar:
	DS	1
_randVar1:
	DS	1
_randObject:
	DS	1
_coinX:
	DS	90
_coinY:
	DS	30
_coinFormation:
	DS	1
_coinAnimate:
	DS	30
_zapperY:
	DS	9
_zapperX:
	DS	6
_zapperLength:
	DS	3
_zapperAnimate:
	DS	3
_missileX:
	DS	2
_missileY:
	DS	1
_missileAnimate:
	DS	1
	SEGMENT DATA
_MAvalue:
	DB	255
	SEGMENT BSS
_laserX:
	DS	1
_laserY:
	DS	1
_laserLifetime:
	DS	3
_laserAnimate:
	DS	1
_deadLasers:
	DS	1
_zapper_tiles_flipped:
	DS	9
_electric_animation:
	DS	24
_powering_tiles_flipped:
	DS	12
_firing_tiles_flipped:
	DS	9
_shutdown_tiles_flipped:
	DS	9
_appvar_1:
	DS	3
_appvar_2:
	DS	3
;    1	/*Jetpack Joyride CE
;    2	
;    3	A Jetpack Joyride port for the TI-84 Plus CE calculators.
;    4	
;    5	Made by King Dub Dub
;    6	
;    7	I'm pretty sure you have the readme if you have this source code, but if you want
;    8	to mod this or something then get ready for some over-commented trash!
;    9	
;   10	*/
;   11	
;   12	#include <stdbool.h>
;   13	#include <stddef.h>
;   14	#include <stdint.h>
;   15	#include <tice.h>
;   16	
;   17	#include <math.h>
;   18	#include <stdio.h>
;   19	#include <stdlib.h>
;   20	#include <string.h>
;   21	
;   22	#include <compression.h>
;   23	#include <graphx.h>
;   24	#include <keypadc.h>
;   25	
;   26	#include "coinShapes.c"
;   27	
;   28	//all the appvar include files:
;   29	#include "sprites/gfx.h"
;   30	//max number of zappers:
;   31	#define MaxZappers 3
;   32	
;   33	//max number of missiles, will probably be replaced with a non-static value later:
;   34	#define MaxMissiles 1
;   35	
;   36	//max number of lasers, will definitely be phased out later:
;   37	#define MaxLasers 1
;   38	
;   39	//the most overused variable ever:
;   40	uint8_t i;
;   41	
;   42	//and now there's two:
;   43	uint8_t i_the_sequel;
;   44	
;   45	//the Jetpack Joyride guy's name is Barry Steakfries, which is what I would name
;   46	//my child if I had the desire to marry and have children.
;   47	uint16_t avatarX;
;   48	uint8_t avatarY;
;   49	
;   50	//avatar's sprite array and values for keeping track of animation frames:
;   51	int8_t avatarAnimate = 1;
;   52	int8_t displacement = 3;
;   53	
;   54	//variable used for calculating fire animations:
;   55	uint8_t flightTime = 18;
;   56	
;   57	//time it takes to complete the game loop, used to control the FPS; if it overflows
;   58	//then we have real problems:
;   59	uint8_t frameTime;
;   60	
;   61	//variables for when jetpack is on or not for math calculations:
;   62	int8_t holdTime;
;   63	
;   64	//speed of scrolling for avatar, obstacles, map, etc.
;   65	uint8_t scrollSpeed;
;   66	
;   67	//measures timings for delays between spawning coins, obstacles, etc.:
;   68	int24_t spawnDelay = 200;
;   69	
;   70	//used for a bad background scroll function that is actually the best for this scenario:
;   71	int24_t backgroundScroll;
;   72	
;   73	//stores if Barry done got wasted or not:
;   74	int8_t health;
;   75	
;   76	//max monies at $4,294,967,295:
;   77	uint32_t monies;
;   78	
;   79	//there's a limit to the distance you can fly in the original game, not sure I'll keep that or not...
;   80	uint32_t distance;
;   81	
;   82	//for randomization values that need to be reused:
;   83	uint8_t randVar;
;   84	uint8_t randVar1;
;   85	
;   86	uint8_t randObject;
;   87	
;   88	uint24_t coinX[MaxCoins];
;   89	uint8_t coinY[MaxCoins];
;   90	//coin formation variable to keep track of coin lists:
;   91	uint8_t coinFormation;
;   92	//values for keeping track of coin animation sprites, all start at zero:
;   93	uint8_t coinAnimate[MaxCoins];
;   94	
;   95	//arrays for zapper coordinates:
;   96	uint24_t zapperY[MaxZappers];
;   97	uint16_t zapperX[MaxZappers];
;   98	//measured in beam units, 10x10 pixels:
;   99	uint8_t zapperLength[MaxZappers];
;  100	//zapper animation count, all start at zero:
;  101	uint8_t zapperAnimate[MaxZappers];
;  102	
;  103	uint16_t missileX[MaxMissiles];
;  104	uint8_t missileY[MaxMissiles];
;  105	//keep track of animations for missiles:
;  106	int8_t missileAnimate;
;  107	int8_t MAvalue = -1;
;  108	
;  109	//all lasers have a universal X that doesn't move very far:
;  110	int8_t laserX;
;  111	//laser Y array:
;  112	uint8_t laserY[MaxLasers];
;  113	//time till firing:
;  114	uint24_t laserLifetime[MaxLasers];
;  115	//keep track of laser animations:
;  116	int8_t laserAnimate[MaxLasers];
;  117	//keep track of how many lasers have fired already:
;  118	uint8_t deadLasers;
;  119	
;  120	//flipped sprites and animations:
;  121	gfx_sprite_t *zapper_tiles_flipped[3];
;  122	gfx_sprite_t *electric_animation[8];
;  123	gfx_sprite_t *powering_tiles_flipped[4];
;  124	gfx_sprite_t *firing_tiles_flipped[3];
;  125	gfx_sprite_t *shutdown_tiles_flipped[3];
;  126	
;  127	//the magic(k)al appvar decompression pointers, make sure to split data somewhat evenly:
;  128	ti_var_t *appvar_1;
;  129	ti_var_t *appvar_2;
	SEGMENT CODE
;  130	
;  131	
;  132	
;  133	//clears all objects from gameplay:
;  134	void delObjects()
;  135	{
_delObjects:
	LD	HL,-6
	CALL	__frameset
;  136	    for (i = 0; i < abbreviatedMax[coinFormation]; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_2
L_0:
;  137	    {
;  138	        coinX[i] = 2000;
	LD	A,(_i)
	UEXT	HL
	LD	BC,2000
	LD	(IX+-6),BC	; spill
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	BC,(IX+-6)	; unspill
	LD	(HL),BC
;  139	        coinY[i] = 0;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinY
	ADD	HL,BC
	LD	(HL),0
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  140	    }
L_2:
	LD	A,(_coinFormation)
	UEXT	HL
	LD	L,A
	LD	BC,_abbreviatedMax
	ADD	HL,BC
	LD	A,(_i)
	CP	A,(HL)
	JR	C,L_0
;  141	
;  142	    for (i = 0; i < MaxZappers; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_5
L_3:
;  143	    {
;  144	        zapperLength[i] = 0;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	(HL),0
;  145	        zapperX[i] = 2000;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	(HL),208
	INC	HL
	LD	(HL),7
;  146	        zapperY[i] = 0;
	LD	A,(_i)
	UEXT	HL
	LD	DE,0
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	(HL),DE
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  147	    }
L_5:
	LD	A,(_i)
	CP	A,3
	JR	C,L_3
;  148	
;  149	    for (i = 0; i < MaxMissiles; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_9
L_7:
;  150	    {
;  151	        missileX[i] = 6001;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_missileX
	ADD	HL,BC
	LD	(HL),113
	INC	HL
	LD	(HL),23
;  152	        missileY[i] = 0;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_missileY
	ADD	HL,BC
	LD	(HL),0
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  153	    }
L_9:
	LD	A,(_i)
	CP	A,1
	JR	C,L_7
;  154	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _delObjects ***************************
;Name                         Addr/Register   Size   Type
;_missileY                           STATIC      1   variable
;_missileX                           STATIC      2   variable
;_zapperY                            STATIC      9   variable
;_zapperX                            STATIC      6   variable
;_zapperLength                       STATIC      3   variable
;_coinFormation                      STATIC      1   variable
;_abbreviatedMax                     IMPORT      6   variable
;_coinY                              STATIC     30   variable
;_coinX                              STATIC     90   variable
;_i                                  STATIC      1   variable


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


;  155	
;  156	void main(void)
;  157	{
_main:
	LD	HL,-82
	CALL	__frameset
;  158	    //flipped zappers:
;  159	    for(i = 0; i < 3; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_14
L_12:
;  160	    {
;  161	        zapper_tiles_flipped[i] = gfx_MallocSprite(18, 18);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,18
	PUSH	BC
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_zapper_tiles_flipped
	ADD	HL,DE
	LD	(HL),BC
;  162	        gfx_FlipSpriteX(zapper_tiles[i], zapper_tiles_flipped[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,BC
	ADD	HL,DE
	LD	DE,(HL)
	PUSH	DE
	LD	HL,BC
	LD	BC,_zapper_tiles_data
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteX
	POP	BC
	POP	BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  163	    }
L_14:
	LD	A,(_i)
	CP	A,3
	JR	C,L_12
;  164	
;  165	    for(i=0; i < 8; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_17
L_15:
;  166	    {
;  167	        //mallocing full flipped electric_animation array:
;  168	        electric_animation[i] = gfx_MallocSprite(32, 32);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,32
	PUSH	BC
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_electric_animation
	ADD	HL,DE
	LD	(HL),BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  169	    }
L_17:
	LD	A,(_i)
	CP	A,8
	JR	C,L_15
;  170	
;  171	    for(i = 0; i < 2; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_21
L_19:
;  172	    {
;  173	        //zapper lightning:
;  174	        electric_animation[i] = electric_tiles[i];
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,BC
	LD	DE,_electric_tiles_data
	ADD	HL,DE
	LD	IY,HL
	LD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LD	BC,(IY)
	LD	(HL),BC
;  175	        gfx_FlipSpriteX(electric_animation[i], electric_animation[i+2]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	INC	HL
	INC	HL
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteX
	POP	BC
	POP	BC
;  176	        gfx_FlipSpriteY(electric_animation[i], electric_animation[i+4]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	HL,IY+4
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteY
	POP	BC
	POP	BC
;  177	        gfx_RotateSpriteHalf(electric_animation[i], electric_animation[i+6]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	HL,IY+6
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_RotateSpriteHalf
	POP	BC
	POP	BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  178	    }
L_21:
	LD	A,(_i)
	CP	A,2
	JR	C,L_19
;  179	
;  180	    //flipping laser powering up animations:
;  181	    for(i = 0; i < 4; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_25
L_23:
;  182	    {
;  183	        powering_tiles_flipped[i] = gfx_MallocSprite(19, 15);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,15
	PUSH	BC
	LD	BC,19
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_powering_tiles_flipped
	ADD	HL,DE
	LD	(HL),BC
;  184	        gfx_FlipSpriteY(powering_tiles[i], powering_tiles_flipped[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,BC
	ADD	HL,DE
	LD	DE,(HL)
	PUSH	DE
	LD	HL,BC
	LD	BC,_powering_tiles_data
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteY
	POP	BC
	POP	BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  185	    }
L_25:
	LD	A,(_i)
	CP	A,4
	JR	C,L_23
;  186	
;  187	    //flipping laser sprites:
;  188	    for(i = 0; i < 3; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_29
L_27:
;  189	    {
;  190	        firing_tiles_flipped[i] = gfx_MallocSprite(30, 37);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,37
	PUSH	BC
	LD	BC,30
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_firing_tiles_flipped
	ADD	HL,DE
	LD	(HL),BC
;  191	        gfx_FlipSpriteY(firing_tiles[i], firing_tiles_flipped[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,BC
	ADD	HL,DE
	LD	DE,(HL)
	PUSH	DE
	LD	HL,BC
	LD	BC,_firing_tiles_data
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteY
	POP	BC
	POP	BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  192	    }
L_29:
	LD	A,(_i)
	CP	A,3
	JR	C,L_27
;  193	
;  194	    for(i = 0; i < 3; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_33
L_31:
;  195	    {
;  196	        shutdown_tiles_flipped[i] = gfx_MallocSprite(30, 37);
	LD	BC,_malloc
	PUSH	BC
	LD	BC,37
	PUSH	BC
	LD	BC,30
	PUSH	BC
	CALL	_gfx_AllocSprite
	POP	BC
	POP	BC
	POP	BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_shutdown_tiles_flipped
	ADD	HL,DE
	LD	(HL),BC
;  197	        gfx_FlipSpriteY(firing_tiles[i], shutdown_tiles_flipped[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,BC
	ADD	HL,DE
	LD	DE,(HL)
	PUSH	DE
	LD	HL,BC
	LD	BC,_firing_tiles_data
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FlipSpriteY
	POP	BC
	POP	BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  198	    }
L_33:
	LD	A,(_i)
	CP	A,3
	JR	C,L_31
;  199	
;  200	    //initialize GFX libraries:
;  201	    gfx_Begin();
	CALL	_gfx_Begin
;  202	    gfx_SetDrawBuffer();
	LD	BC,1
	PUSH	BC
	CALL	_gfx_SetDraw
	POP	BC
;  203	
;  204	    gfx_SetPalette(jetpack_palette, sizeof_jetpack_palette, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,512
	PUSH	BC
	LD	BC,_jetpack_palette
	PUSH	BC
	CALL	_gfx_SetPalette
	POP	BC
	POP	BC
	POP	BC
;  205	    gfx_SetTransparentColor(0);
	LD	BC,0
	PUSH	BC
	CALL	_gfx_SetTransparentColor
	POP	BC
;  206	
;  207	    //start up a timer for FPS monitoring, do not move:
;  208	    timer_Control = TIMER1_ENABLE | TIMER1_32K | TIMER1_UP;
	LD	HL,15859760
	LD	(HL),3
	INC	HL
;  209	
;  210	    //best scan mode according to the angry lettuce man:
;  211	    kb_SetMode(MODE_3_CONTINUOUS);
;  212	
;  213	    //all text printed is gray:
;  214	    gfx_SetTextFGColor(2);
	LD	BC,2
	PUSH	BC
	LD	(HL),2
	LD	A,(16056320)
	AND	A,252
	OR	A,3
	LD	(16056320),A
	CALL	_gfx_SetTextFGColor
	POP	BC
;  215	
;  216	    //when I first started using C, I asked some friends if there were GOTO statements.
;  217	    //They proved they were good friends, and told me "No, that's stupid". I'm glad they lied.
;  218	    GAMESTART:
L_36:
;  219	    //But it's still sometimes okay.
;  220	
;  221	    //reset variables for when a game starts:
;  222	    scrollSpeed = 6;
	LD	A,6
	LD	(_scrollSpeed),A
;  223	    avatarX = 24;
	LD	HL,_avatarX
	LD	(HL),24
	INC	HL
	LD	(HL),0
;  224	    avatarY = 185;
	LD	A,185
	LD	(_avatarY),A
;  225	    holdTime = 0;
	XOR	A,A
	LD	(_holdTime),A
;  226	    flightTime = 18;
	LD	A,18
	LD	(_flightTime),A
;  227	    health = 1;
	LD	A,1
	LD	(_health),A
;  228	    spawnDelay = 100;
	LD	BC,100
	LD	(_spawnDelay),BC
;  229	    distance = 0;
	LD	BC,0
	LD	(_distance),BC
	XOR	A,A
	LD	(_distance+3),A
;  230	    monies = 0;
	LD	(_monies),BC
	XOR	A,A
	LD	(_monies+3),A
;  231	
;  232	    deadLasers = 10;
	LD	A,10
	LD	(_deadLasers),A
;  233	
;  234	    delObjects();
	CALL	_delObjects
;  235	
;  236	    // Loop until clear is pressed:
;  237	    do{
L_188:
;  238	        //update keys, fixes bugs with update errors that can lead to softlocks:
;  239	        kb_Scan();
	CALL	_kb_Scan
;  240	
;  241	        if ((backgroundScroll - scrollSpeed) <= 0)
	LD	A,(_scrollSpeed)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(_backgroundScroll)
	OR	A,A
	SBC	HL,BC
	LD	(IX+-48),HL
	LD	BC,HL
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_38
;  242	        {
;  243	            backgroundScroll += (192 - scrollSpeed);
	LD	A,(_scrollSpeed)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,192
	OR	A,A
	SBC	HL,BC
	LD	BC,(_backgroundScroll)
	ADD	HL,BC
	LD	(_backgroundScroll),HL
;  244	        } else {
	JR	L_65
L_38:
;  245	            backgroundScroll -= scrollSpeed;
	LD	BC,(IX+-48)
	LD	(_backgroundScroll),BC
;  246	        }
L_65:
;  247	
;  248	        //spawns stuff, SO much better than the debug methods I originally used:
;  249	        if (spawnDelay <= 0)
	LD	BC,(_spawnDelay)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_64
;  250	        {
;  251	            randObject = randInt(0,10);
	CALL	_random
	LD	BC,11
	CALL	__iremu
	LD	A,L
;  252	
;  253	            if (randObject == 1)
	CP	A,1
	LD	(_randObject),A
	JR	NZ,L_62
;  254	            {
;  255	                //sets coin coordinates from coordinate lists:
;  256	                randVar = randInt(30, 150);
	CALL	_random
	LD	BC,121
	CALL	__iremu
	LD	IY,HL
	LEA	HL,IY+30
	LD	A,L
	LD	(_randVar),A
;  257	                coinFormation = randInt(0, 5);
	CALL	_random
	LD	BC,6
	CALL	__iremu
	LD	A,L
	LD	(_coinFormation),A
;  258	                for(i = 0; i < MaxCoins; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_41
L_39:
;  259	                {
;  260	                    coinX[i] = ctx[coinFormation][i] + 330;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	A,(_coinFormation)
	UEXT	HL
	LD	L,A
	LD	A,90
	CALL	__imul_b
	LD	DE,_ctx
	ADD	HL,DE
	LD	DE,BC
	ADD	HL,DE
	LD	IY,HL
	LD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	(IX+-72),IY	; spill
	LD	(IX+-75),HL	; spill
	LD	IY,(IX+-72)	; unspill
	LD	HL,(IY)
	LD	BC,330
	ADD	HL,BC
	LD	IY,(IX+-75)	; unspill
	LD	(IY),HL
;  261	                    coinY[i] = cty[coinFormation][i] + randVar;
	LD	A,(_coinFormation)
	UEXT	HL
	LD	L,A
	LD	A,30
	CALL	__imul_b
	LD	BC,_cty
	ADD	HL,BC
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,BC
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinY
	ADD	HL,BC
	LD	A,(IY)
	LD	BC,(_randVar)
	ADD	A,C
	LD	(HL),A
;  262	                    coinAnimate[i] = 0;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinAnimate
	ADD	HL,BC
	LD	(HL),0
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  263	                }
L_41:
	LD	A,(_i)
	CP	A,30
	JR	C,L_39
;  264	
;  265	                spawnDelay = 500;
	LD	BC,500
	LD	(_spawnDelay),BC
;  266	
;  267	            } else if (randObject == 2) {
	JR	L_88
L_62:
	LD	A,(_randObject)
	CP	A,2
	JR	NZ,L_60
;  268	
;  269	                //spawns missiles (and missile swarms if I implement them):
;  270	                for (i = 0; i < MaxMissiles; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_46
L_44:
;  271	                {
;  272	                    if (missileX[i] > 6000)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_missileX
	ADD	HL,BC
	LD	(IX+-42),HL
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,6000
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_45
;  273	                    {
;  274	                        missileX[i] = 1466;
	LD	HL,(IX+-42)
	LD	(HL),186
	INC	HL
	LD	(HL),5
;  275	                        missileY[i] = 10 * randInt(2, 18);
	CALL	_random
	LD	BC,17
	CALL	__iremu
	INC	HL
	INC	HL
	LD	B,L
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	C,10
	LD	DE,_missileY
	ADD	HL,DE
	MLT	BC
	LD	(HL),C
;  276	
;  277	                        i = MaxZappers;
	LD	A,3
	LD	(_i),A
;  278	                    }
;  279	                }
L_45:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_46:
	LD	A,(_i)
	CP	A,1
	JR	C,L_44
	JR	L_88
;  280	
;  281	                //missiles have their own "delay" and don't need to reset spawnDelay.
;  282	
;  283	            } else if (randObject == 3) {
L_60:
	LD	A,(_randObject)
	CP	A,3
	JR	NZ,L_58
;  284	
;  285	                //give each laser their Y-axis:
;  286	                for(i = 0; i < MaxLasers; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_49
L_47:
;  287	                {
;  288	                    laserY[i] = randInt(30, 200);
	CALL	_random
	LD	BC,171
	CALL	__iremu
	LD	IY,HL
	LEA	HL,IY+30
	LD	B,L
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,_laserY
	ADD	HL,DE
	LD	(HL),B
;  289	                    laserLifetime[i] = 100;
	LD	A,(_i)
	UEXT	HL
	LD	BC,100
	LD	L,A
	LD	DE,HL
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_laserLifetime
	ADD	HL,DE
	LD	(HL),BC
	LD	A,(_i)
	INC	A
	LD	(_i),A
;  290	                }
L_49:
	LD	A,(_i)
	CP	A,1
	JR	C,L_47
;  291	
;  292	                laserX = 1;
	LD	A,1
	LD	(_laserX),A
;  293	
;  294	                deadLasers = 0;
	XOR	A,A
	LD	(_deadLasers),A
;  295	
;  296	                spawnDelay = scrollSpeed * 150;
	LD	A,(_scrollSpeed)
	UEXT	HL
	LD	L,A
	LD	A,150
	CALL	__imul_b
	LD	(_spawnDelay),HL
;  297	
;  298	            } else if (randObject <= 10) {
	JR	L_88
L_58:
	LD	A,10
	LD	HL,_randObject
	CP	A,(HL)
	JR	C,L_88
;  299	
;  300	                //randomly generates zapper coordinates and lengths:
;  301	                for (i = 0; i < MaxZappers; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_54
L_52:
;  302	                {
;  303	                    if (zapperX[i] > 330)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	(IX+-45),HL
	LD	BC,(HL)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,330
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_53
;  304	                    {
;  305	                        zapperX[i] = 330;
	LD	HL,(IX+-45)
	LD	(HL),74
	INC	HL
	LD	(HL),1
;  306	
;  307	                        zapperLength[i] = randInt(2, 4);
	CALL	_random
	LD	A,(_i)
	LD	BC,3
	CALL	__iremu
	INC	HL
	INC	HL
	LD	B,L
	UEXT	HL
	LD	L,A
	LD	DE,_zapperLength
	ADD	HL,DE
	LD	(HL),B
;  308	                        zapperY[i] = 10 * randInt(2, 19 - zapperLength[i]);
	CALL	_random
	LD	DE,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,10
	LD	BC,HL
	LD	HL,19
	OR	A,A
	SBC	HL,BC
	LD	BC,HL
	LD	HL,DE
	DEC	BC
	CALL	__iremu
	INC	HL
	INC	HL
	CALL	__imul_b
	LD	BC,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	DE,HL
;  309	
;  310	                        i = MaxZappers;
	LD	A,3
	ADD	HL,HL
	ADD	HL,DE
	LD	DE,_zapperY
	ADD	HL,DE
	LD	(HL),BC
	LD	(_i),A
;  311	                    }
;  312	                }
L_53:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_54:
	LD	A,(_i)
	CP	A,3
	JR	C,L_52
;  313	
;  314	                spawnDelay = 200;
	LD	BC,200
	LD	(_spawnDelay),BC
;  315	            }
;  316	        } else {
	JR	L_88
L_64:
;  317	            spawnDelay -= scrollSpeed;
	LD	A,(_scrollSpeed)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(_spawnDelay)
	OR	A,A
	SBC	HL,BC
	LD	(_spawnDelay),HL
;  318	        }
L_88:
;  319	
;  320	        //run controls until Barry gets wasted, then bounces his corpse around:
;  321	        if (health > 0)
	XOR	A,A
	LD	HL,_health
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_96
;  322	        {
;  323	            if (kb_Data[1] & kb_2nd)
	LD	A,(16056338)
	AND	A,32
	JR	Z,L_80
;  324	            {
;  325	                if((avatarY > 20) && (holdTime < 12))
	LD	A,20
	LD	HL,_avatarY
	CP	A,(HL)
	JR	NC,L_69
	LD	A,(_holdTime)
	CP	A,12
	JP	P,L_69
;  326	                {
;  327	                    holdTime += 1;
	LD	A,(_holdTime)
	INC	A
	LD	(_holdTime),A
;  328	                }
L_69:
;  329	
;  330	                if (flightTime > 7)
	LD	A,7
	LD	HL,_flightTime
	CP	A,(HL)
	JR	NC,L_71
;  331	                {
;  332	                    flightTime = 0;
	XOR	A,A
	LD	(_flightTime),A
;  333	                }
L_71:
;  334	
;  335	                if (flightTime < 7)
	LD	A,(_flightTime)
	CP	A,7
	JR	NC,L_81
;  336	                {
;  337	                    ++flightTime;
	LD	A,(_flightTime)
	INC	A
	LD	(_flightTime),A
;  338	                }
;  339	
;  340	            } else {
	JR	L_81
L_80:
;  341	
;  342	                if((avatarY < (185)) && (holdTime > -10))
	LD	A,(_avatarY)
	CP	A,185
	JR	NC,L_78
	LD	A,246
	LD	HL,_holdTime
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_78
;  343	                {
;  344	                    holdTime -= 1;
	LD	A,(_holdTime)
	DEC	A
	LD	(_holdTime),A
;  345	                }
L_78:
;  346	
;  347	                if (flightTime < 7)
	LD	A,(_flightTime)
	CP	A,7
	JR	NC,L_77
;  348	                {
;  349	                    flightTime = 8;
	LD	A,8
	LD	(_flightTime),A
;  350	
;  351	                } else if (flightTime < 11) {
	JR	L_81
L_77:
	LD	A,(_flightTime)
	CP	A,11
	JR	NC,L_75
;  352	
;  353	                    ++flightTime;
	LD	A,(_flightTime)
	INC	A
	LD	(_flightTime),A
;  354	
;  355	                } else {
	JR	L_81
L_75:
;  356	
;  357	                    flightTime = 18;
	LD	A,18
	LD	(_flightTime),A
;  358	                }
;  359	            }
L_81:
;  360	
;  361	            //SAX got pretty mad about this part, turns out a linear equation can model a curve and
;  362	            //is actually better than a cubic function:
;  363	            avatarY -= (holdTime);
	LD	BC,(_holdTime)
	LD	A,(_avatarY)
	SUB	A,C
	LD	(_avatarY),A
;  364	
;  365	            //sees if Y-value rolled past zero or 198, figures out if it was going up
;  366	            //or down, and auto-corrects accordingly:
;  367	            if ((avatarY > (186)) || (avatarY < 20))
	LD	A,186
	LD	HL,_avatarY
	CP	A,(HL)
	JR	C,L_86
	LD	A,(_avatarY)
	CP	A,20
	JR	NC,L_96
L_86:
;  368	            {
;  369	                if (holdTime > 0)
	XOR	A,A
	LD	HL,_holdTime
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_84
;  370	                {
;  371	                    avatarY = 20;
	LD	A,20
	LD	(_avatarY),A
;  372	                } else {
	JR	L_85
L_84:
;  373	                    avatarY = 185;
	LD	A,185
	LD	(_avatarY),A
;  374	                }
L_85:
;  375	                holdTime = 0;
	XOR	A,A
	LD	(_holdTime),A
;  376	            }
;  377	        }
L_96:
;  378	
;  379	        //bit that runs avatar animations:
;  380	        if (avatarY < 185)
	LD	A,(_avatarY)
	CP	A,185
	JR	NC,L_95
;  381	        {
;  382	            displacement = 9;
	LD	A,9
	LD	(_displacement),A
;  383	        } else {
	JR	L_97
L_95:
;  384	
;  385	            if (displacement == 9)
	LD	A,(_displacement)
	CP	A,9
	JR	NZ,L_92
;  386	            {
;  387	                displacement = 3;
	LD	A,3
	LD	(_displacement),A
;  388	            }
L_92:
;  389	
;  390	            if((displacement < 1) || (displacement > 7))
	LD	A,(_displacement)
	CP	A,1
	CALL	__setflag
	JP	M,L_91
	LD	A,7
	LD	HL,_displacement
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_93
L_91:
;  391	            {
;  392	                avatarAnimate *= -1;
	LD	A,(_avatarAnimate)
	NEG	
	LD	(_avatarAnimate),A
;  393	            }
L_93:
;  394	
;  395	            displacement += avatarAnimate;
	LD	BC,(_avatarAnimate)
	LD	A,(_displacement)
	ADD	A,C
	LD	(_displacement),A
;  396	        }
L_97:
;  397	
;  398	        //this is the best way I've found to draw the backgrounds, smaller and faster than a smart system:
;  399	        gfx_Sprite(background, backgroundScroll - 192, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,16777024
	LD	HL,(_backgroundScroll)
	ADD	HL,BC
	PUSH	HL
	LD	BC,_background_data
	PUSH	BC
	CALL	_gfx_Sprite
	POP	BC
	POP	BC
	POP	BC
;  400	        gfx_Sprite(background, backgroundScroll, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,(_backgroundScroll)
	PUSH	BC
	LD	BC,_background_data
	PUSH	BC
	CALL	_gfx_Sprite
	POP	BC
	POP	BC
	POP	BC
;  401	        gfx_Sprite(background, backgroundScroll + 192, 0);
	LD	BC,0
	PUSH	BC
	LD	BC,192
	LD	HL,(_backgroundScroll)
	ADD	HL,BC
	PUSH	HL
	LD	BC,_background_data
	PUSH	BC
	CALL	_gfx_Sprite
	POP	BC
	POP	BC
	POP	BC
;  402	
;  403	        //draws the avatar, everything is layered over it:
;  404	        gfx_TransparentSprite_NoClip(avatar_tiles[displacement/3], avatarX, avatarY-abs((displacement/3)-1));
	LD	A,(_displacement)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,3
	CALL	__idivs
	DEC	HL
	PUSH	HL
	CALL	_abs
	POP	BC
	LD	A,(_avatarY)
	SUB	A,L
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,(_avatarX)
	LD	A,(_displacement)
	LD	D,A
	CALL	__stoiu
	PUSH	HL
	SEXT	HL
	LD	L,D
	LD	BC,3
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_avatar_tiles_data
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
;  405	
;  406	        //bit that draws exhaust when in flight:
;  407	        if (flightTime < 18)
	LD	A,(_flightTime)
	CP	A,18
	JR	NC,L_112
;  408	        {
;  409	            gfx_TransparentSprite_NoClip(exhaust_tiles[flightTime/2], avatarX+randInt(1,3), avatarY+31);
	LD	A,(_avatarY)
	ADD	A,31
	LD	C,A
	LD	B,0
	PUSH	BC
	CALL	_random
	LD	BC,3
	CALL	__iremu
	LD	DE,HL
	INC	DE
	LD	BC,(_avatarX)
	CALL	__stoiu
	ADD	HL,DE
	PUSH	HL
	LD	A,(_flightTime)
	UEXT	HL
	LD	L,A
	LD	BC,2
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_exhaust_tiles_data
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
;  410	            gfx_TransparentSprite_NoClip(nozzle, avatarX+4, avatarY+31);
	LD	A,(_avatarY)
	ADD	A,31
	LD	C,A
	LD	B,0
	PUSH	BC
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+4
	PUSH	BC
	LD	BC,_nozzle_data
	PUSH	BC
	CALL	_gfx_TransparentSprite_NoClip
	POP	BC
	POP	BC
	POP	BC
;  411	        }
L_112:
;  412	
;  413	        //bit that runs coin collision and movement:
;  414	        for(i = 0; i < abbreviatedMax[coinFormation]; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_111
L_109:
;  415	        {
;  416	            if (coinX[i] < 1000)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	(IX+-3),HL
	OR	A,A
	LD	HL,(HL)
	LD	BC,1000
	SBC	HL,BC
	JR	NC,L_110
;  417	            {
;  418	                //collision detection and appropriate sprite drawing:
;  419	                if (coinX[i] < 330)
	LD	HL,(IX+-3)
	LD	HL,(HL)
	LD	BC,330
	OR	A,A
	SBC	HL,BC
	JR	NC,L_107
;  420	                {
;  421	                    if (gfx_CheckRectangleHotspot(avatarX+6,avatarY,18,40,coinX[i]-11,coinY[i]+1,10,10))
	LD	BC,(IX+-3)
	LD	(IX+-33),BC
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+24
	OR	A,A
	LD	HL,(IX+-3)
	LD	IY,(HL)
	LEA	HL,IY+-11
	SBC	HL,BC
	JR	NC,L_105
	LD	BC,(IX+-3)
	LD	(IX+-33),BC
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,HL
	LEA	HL,IY+6
	LD	IY,(IX+-3)
	LD	BC,(IY)
	DEC	BC
	OR	A,A
	SBC	HL,BC
	JR	NC,L_105
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinY
	ADD	HL,BC
	LD	(IX+-24),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	INC	BC
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	DE,IY+40
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	CALL	__setflag
	JP	P,L_105
	LD	HL,(IX+-24)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	OR	A,A
	LEA	BC,IY+11
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_105
;  422	                    {
;  423	                        gfx_TransparentSprite(sparkle, coinX[i]-13, coinY[i]-1);
	LD	HL,(IX+-24)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	DEC	HL
	PUSH	HL
	LD	HL,(IX+-3)
	LD	IY,(HL)
	LEA	BC,IY+-13
	PUSH	BC
	LD	BC,_sparkle_data
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  424	
;  425	                        coinX[i] = 1020;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	BC,1020
	LD	(HL),BC
;  426	                        ++monies;
	LD	A,(_monies+3)
	LD	E,A
	LD	A,1
	LD	HL,(_monies)
	CALL	__ladd_b
	LD	(_monies),HL
	LD	A,E
	LD	(_monies+3),A
;  427	                    } else {
	JR	L_107
L_105:
;  428	                        gfx_TransparentSprite(coin_tiles[(coinAnimate[i]/10)], (coinX[i]-12), coinY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinAnimate
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	LD	IY,(IX+-33)
	LD	IY,(IY)
	ADD	HL,BC
	LD	BC,_coin_tiles_data
	ADD	HL,BC
	LEA	BC,IY+-12
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  429	
;  430	                        if (coinAnimate[i] < 38)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_coinAnimate
	ADD	HL,BC
	LD	(IX+-12),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,38
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_103
;  431	                        {
;  432	                            coinAnimate[i] += 2;
	LD	HL,(IX+-12)
	LD	A,(HL)
	INC	A
	INC	A
	LD	HL,(IX+-12)
	LD	(HL),A
;  433	                        } else {
	JR	L_107
L_103:
;  434	                            coinAnimate[i] = 0;
	LD	HL,(IX+-12)
	LD	(HL),0
;  435	                        }
;  436	                    }
;  437	                }
L_107:
;  438	
;  439	                coinX[i] -= scrollSpeed;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_coinX
	ADD	HL,BC
	LD	(IX+-51),HL
	LD	A,(_scrollSpeed)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,(IX+-51)
	LD	HL,(HL)
	LD	IY,(IX+-51)
	OR	A,A
	SBC	HL,BC
	LD	(IY),HL
;  440	            }
;  441	        }
L_110:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_111:
	LD	A,(_coinFormation)
	UEXT	HL
	LD	L,A
	LD	BC,_abbreviatedMax
	ADD	HL,BC
	LD	A,(_i)
	CP	A,(HL)
	JR	C,L_109
;  442	
;  443	        //bit that calculates zappers 'n stuff:
;  444	        for (i = 0; i < MaxZappers; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_130
L_128:
;  445	        {
;  446	            //drawing the zapper beams:
;  447	            if (zapperX[i] < 1000)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,1000
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_129
;  448	            {
;  449	                for (i_the_sequel = 0; i_the_sequel < zapperLength[i]; ++i_the_sequel)
	XOR	A,A
	LD	(_i_the_sequel),A
	JR	L_115
L_113:
;  450	                {
;  451	                    gfx_TransparentSprite(beam, zapperX[i]-14, zapperY[i]+16+(i_the_sequel*10));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_i_the_sequel)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LEA	BC,IY+16
	ADD	HL,BC
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+-14
	PUSH	BC
	LD	BC,_beam_data
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
	LD	A,(_i_the_sequel)
	INC	A
	LD	(_i_the_sequel),A
;  452	                }
L_115:
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(_i_the_sequel)
	CP	A,(HL)
	JR	C,L_113
;  453	
;  454	                //draw zapper pairs and beams with distance of zapperLength between them:
;  455	                if (zapperX[i] < 336)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,336
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_126
;  456	                {
;  457	                    randVar = randInt(0,1);
	CALL	_random
	LD	A,L
	AND	A,1
	LD	(_randVar),A
;  458	                    randVar1 = randInt(0,1);
	CALL	_random
	LD	A,L
	AND	A,1
	LD	(_randVar1),A
;  459	
;  460	                    gfx_TransparentSprite(electric_animation[randVar+2+(randVar1*4)], zapperX[i]-25, zapperY[i]-7);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LEA	BC,IY+-7
	PUSH	BC
	LD	IY,HL
	LD	A,(_randVar1)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,HL
	LD	A,(_randVar)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	INC	BC
	INC	BC
	LD	HL,DE
	ADD	HL,BC
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LEA	BC,IY+-25
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  461	                    gfx_TransparentSprite(electric_animation[randVar], zapperX[i]-25,  zapperY[i]+7+(zapperLength[i]*10));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LEA	BC,IY+7
	ADD	HL,BC
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LD	A,(_randVar)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_electric_animation
	ADD	HL,BC
	LEA	BC,IY+-25
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  462	
;  463	                    gfx_TransparentSprite(zapper_tiles_flipped[zapperAnimate[i]/10], zapperX[i]-18, zapperY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperAnimate
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapper_tiles_flipped
	ADD	HL,BC
	LEA	BC,IY+-18
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  464	                    gfx_TransparentSprite(zapper_tiles[zapperAnimate[i]/10], zapperX[i]-18, zapperY[i]+14+(zapperLength[i]*10));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LEA	BC,IY+14
	ADD	HL,BC
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperAnimate
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,10
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapper_tiles_data
	ADD	HL,BC
	LEA	BC,IY+-18
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  465	
;  466	                    if (zapperAnimate[i] < 28)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperAnimate
	ADD	HL,BC
	LD	(IX+-15),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	OR	A,A
	LD	BC,28
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_117
;  467	                    {
;  468	                        zapperAnimate[i] += 2;
	LD	HL,(IX+-15)
	LD	A,(HL)
	INC	A
	INC	A
	LD	HL,(IX+-15)
	LD	(HL),A
;  469	                    } else {
	JR	L_123
L_117:
;  470	                        zapperAnimate[i] = 0;
	LD	HL,(IX+-15)
	LD	(HL),0
;  471	                    }
L_123:
;  472	
;  473	                    //collision for zappers:
;  474	                    if ((health > 0) && (gfx_CheckRectangleHotspot(avatarX+6, zapperY[i]+2, 18, (zapperLength[i]*10)+30, zapperX[i]-14, avatarY, 10, 50)))
	XOR	A,A
	LD	HL,_health
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_126
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	(IX+-27),HL
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,(IX+-27)
	LD	BC,(IY)
	LD	IY,HL
	LEA	DE,IY+24
	CALL	__stoiu
	LD	IY,HL
	LEA	HL,IY+-14
	OR	A,A
	SBC	HL,DE
	CALL	__setflag
	JP	P,L_126
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,(IX+-27)
	LD	BC,(IY)
	LD	IY,HL
	CALL	__stoiu
	LEA	DE,IY+6
	LD	BC,HL
	DEC	BC
	DEC	BC
	DEC	BC
	DEC	BC
	OR	A,A
	LD	HL,DE
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_126
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_zapperY
	ADD	HL,BC
	LD	IY,(HL)
	LEA	BC,IY+2
	LD	(IX+-30),BC
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_zapperLength
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,10
	CALL	__imul_b
	LD	IY,HL
	LEA	HL,IY+30
	LD	BC,(IX+-30)
	ADD	HL,BC
	LD	BC,HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	OR	A,A
	SBC	HL,BC
	JR	NC,L_126
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+50
	LD	HL,(IX+-30)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_126
;  475	                    {
;  476	                        --health;
	LD	A,(_health)
	DEC	A
	LD	(_health),A
;  477	                    }
;  478	                }
L_126:
;  479	
;  480	                zapperX[i] -= scrollSpeed;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_zapperX
	ADD	HL,BC
	LD	(IX+-54),HL
	LD	HL,(HL)
	LD	A,(_scrollSpeed)
	OR	A,A
	LD	C,A
	LD	B,0
	SBC.SIS	HL,BC
	LD	BC,HL
	LD	HL,(IX+-54)
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  481	            }
;  482	        }
L_129:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_130:
	LD	A,(_i)
	CP	A,3
	JR	C,L_128
;  483	
;  484	        //bit that draws and calculates the missiles 'o death:
;  485	        for (i = 0; i < MaxMissiles; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_152
L_150:
;  486	        {
;  487	            if (missileX[i] < 6001)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_missileX
	ADD	HL,BC
	LD	(IX+-9),HL
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,6001
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_151
;  488	            {
;  489	                if (missileX[i] < 366)
	LD	HL,(IX+-9)
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,366
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_144
;  490	                {
;  491	                    gfx_TransparentSprite(missile, missileX[i]-46, missileY[i]-18);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_missileY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+-18
	PUSH	BC
	LD	HL,(IX+-9)
	LD	BC,(HL)
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+-46
	PUSH	BC
	LD	BC,_missile_data
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  492	
;  493	                    if ((health > 0) && (gfx_CheckRectangleHotspot(missileX[i]-45, avatarY, 19, 40, avatarX+6, missileY[i]-5, 18, 12)))
	XOR	A,A
	LD	HL,_health
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_147
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_missileX
	ADD	HL,BC
	LD	(IX+-36),HL
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,(IX+-36)
	LD	BC,(IY)
	LD	IY,HL
	LEA	DE,IY+6
	CALL	__stoiu
	LD	IY,HL
	LEA	BC,IY+-26
	LD	HL,DE
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_147
	LD	BC,(_avatarX)
	CALL	__stoiu
	LD	IY,(IX+-36)
	LD	BC,(IY)
	LD	IY,HL
	CALL	__stoiu
	LEA	BC,IY+24
	LD	IY,HL
	LEA	HL,IY+-45
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_147
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_missileY
	ADD	HL,BC
	LD	(IX+-39),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LEA	BC,IY+-5
	LD	IY,HL
	LEA	DE,IY+40
	LD	HL,BC
	OR	A,A
	SBC	HL,DE
	CALL	__setflag
	JP	P,L_147
	LD	HL,(IX+-39)
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	OR	A,A
	LEA	BC,IY+7
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_147
;  494	                    {
;  495	                        --health;
	LD	A,(_health)
	DEC	A
	LD	(_health),A
;  496	                    }
;  497	
;  498	                } else if (missileX[i] < 641) {
	JR	L_147
L_144:
	LD	HL,(IX+-9)
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,641
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_142
;  499	
;  500	                    //AW CRAP HERE COME DAT BOI!
;  501	                    gfx_TransparentSprite(missileIncoming_tiles[missileAnimate/3], 281+randInt(-1,1), missileY[i]-16+randInt(-1,1));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_missileY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+-16
	LD	(IX+-69),BC	; spill
	CALL	_random
	LD	BC,3
	CALL	__iremu
	LD	BC,HL
	DEC	BC
	LD	(IX+-66),BC	; spill
	LD	HL,(IX+-69)
	LD	BC,(IX+-66)	; unspill
	ADD	HL,BC
	PUSH	HL
	CALL	_random
	LD	BC,3
	CALL	__iremu
	LD	BC,280
	LD	A,(_missileAnimate)
	LD	D,A
	ADD	HL,BC
	PUSH	HL
	SEXT	HL
	LD	L,D
	LD	BC,3
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_missileIncoming_tiles_data
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  502	
;  503	                } else if (missileX[i] < 1467) {
	JR	L_147
L_142:
	LD	HL,(IX+-9)
	LD	BC,(HL)
	CALL	__stoiu
	OR	A,A
	LD	BC,1467
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_147
;  504	
;  505	                    //plenty of time to dodge (at the beginning at least)
;  506	                    gfx_TransparentSprite(missileWarning_tiles[missileAnimate/2], 293, missileY[i]-11);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_missileY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	A,(_missileAnimate)
	LD	B,A
	LD	IY,HL
	SEXT	HL
	LD	L,B
	LD	BC,2
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LEA	BC,IY+-11
	PUSH	BC
	LD	BC,_missileWarning_tiles_data
	ADD	HL,BC
	LD	BC,293
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  507	
;  508	                    //tracking on avatar
;  509	                    if (missileY[i] < (avatarY + 20))
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_missileY
	ADD	HL,BC
	LD	(IX+-6),HL
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LD	IY,(IX+-6)
	LD	A,(IY)
	LD	IY,HL
	UEXT	HL
	LD	L,A
	OR	A,A
	LEA	BC,IY+20
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_139
;  510	                    {
;  511	                        missileY[i] += 2;
	LD	HL,(IX+-6)
	LD	A,(HL)
	INC	A
	INC	A
	LD	HL,(IX+-6)
	LD	(HL),A
;  512	                    } else if (missileY[i] > (avatarY + 21)) {
	JR	L_147
L_139:
	LD	A,(_avatarY)
	UEXT	HL
	LD	L,A
	LD	IY,(IX+-6)
	LD	A,(IY)
	LD	IY,HL
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LEA	HL,IY+21
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_147
;  513	                        missileY[i] -= 2;
	LD	HL,(IX+-6)
	LD	A,(HL)
	DEC	A
	DEC	A
	LD	HL,(IX+-6)
	LD	(HL),A
;  514	                    }
;  515	                }
L_147:
;  516	
;  517	                //make missileAnimate go up and down between 0 and 5 by toggling MAvalue:
;  518	                if ((missileAnimate < 1) || (missileAnimate > 4))
	LD	A,(_missileAnimate)
	CP	A,1
	CALL	__setflag
	JP	M,L_146
	LD	A,4
	LD	HL,_missileAnimate
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_148
L_146:
;  519	                {
;  520	                    MAvalue *= -1;
	LD	A,(_MAvalue)
	NEG	
	LD	(_MAvalue),A
;  521	                }
L_148:
;  522	                missileAnimate += MAvalue;
	LD	BC,(_MAvalue)
	LD	A,(_missileAnimate)
	ADD	A,C
	LD	(_missileAnimate),A
;  523	
;  524	                //missiles travel by 6 pixels each frame. It was surprisingly tedious to figure that out
;  525	                //from frame-by-frame reviewing of missiles; however, it's too slow on the calc.
;  526	                missileX[i] -= scrollSpeed + 8;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	ADD	HL,HL
	LD	BC,_missileX
	ADD	HL,BC
	LD	(IX+-57),HL
	LD	A,(_scrollSpeed)
	LD	C,A
	LD	B,0
	LD	IY,BC
	LD	HL,(IX+-57)
	LD	HL,(HL)
	LEA	BC,IY+8
	OR	A,A
	SBC.SIS	HL,BC
	LD	BC,HL
	LD	HL,(IX+-57)
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  527	            }
;  528	        }
L_151:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_152:
	LD	A,(_i)
	CP	A,1
	JR	C,L_150
;  529	
;  530	        //move lasers into play when needed:
;  531	        if ((laserX < 20) && (deadLasers < MaxLasers))
	LD	A,(_laserX)
	CP	A,20
	CALL	__setflag
	JP	P,L_158
	LD	A,(_deadLasers)
	CP	A,1
	JR	NC,L_158
;  532	        {
;  533	            ++laserX;
	LD	A,(_laserX)
	INC	A
	LD	(_laserX),A
;  534	        } else if((deadLasers >= MaxLasers) && (laserX > 0)) {
	JR	L_183
L_158:
	LD	A,(_deadLasers)
	CP	A,1
	JR	C,L_183
	XOR	A,A
	LD	HL,_laserX
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_183
;  535	            --laserX;
	LD	A,(_laserX)
	DEC	A
	LD	(_laserX),A
;  536	        }
L_183:
;  537	
;  538	        //bit for lasers, lots of moving parts:
;  539	        for(i = 0; i < MaxLasers; ++i)
	XOR	A,A
	LD	(_i),A
	JR	L_182
L_180:
;  540	        {
;  541	            if (laserX > 0)
	XOR	A,A
	LD	HL,_laserX
	CP	A,(HL)
	CALL	__setflag
	JP	P,L_181
;  542	            {
;  543	                //reset the laser animations:
;  544	                if ((laserX < 20) && (deadLasers < MaxLasers))
	LD	A,(_laserX)
	CP	A,20
	CALL	__setflag
	JP	P,L_177
	LD	A,(_deadLasers)
	CP	A,1
	JR	NC,L_177
;  545	                {
;  546	                    laserAnimate[i] = 0;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserAnimate
	ADD	HL,BC
	LD	(HL),0
;  547	
;  548	                    //draw an inactive laser:
;  549	                    gfx_TransparentSprite(powering_tiles[0], laserX-19, laserY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_laserX)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	IY,HL
	LEA	BC,IY+-19
	PUSH	BC
	LD	BC,(_powering_tiles_data)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  550	                    gfx_TransparentSprite(powering_tiles[0], 320 - laserX, laserY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_laserX)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,320
	OR	A,A
	SBC	HL,BC
	PUSH	HL
	LD	BC,(_powering_tiles_data)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  551	
;  552	                } else {
	JR	L_178
L_177:
;  553	                    //if they are finished, finish the animation sequence and hide them again:
;  554	                    if(deadLasers >= MaxLasers)
	LD	A,(_deadLasers)
	CP	A,1
	JR	C,L_175
;  555	                    {
;  556	                        laserAnimate[i] = 0;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserAnimate
	ADD	HL,BC
	LD	(HL),0
;  557	
;  558	                    //if they aren't dead and have moved, run through their animations and attacks:
;  559	                    } else {
	JR	L_178
L_175:
;  560	
;  561	                        //check to see if the half-life ended:
;  562	                        if(laserLifetime[i] < 1)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_laserLifetime
	ADD	HL,BC
	LD	(IX+-21),HL
	OR	A,A
	LD	HL,(HL)
	LD	BC,1
	SBC	HL,BC
	JR	NC,L_169
;  563	                        {
;  564	                            ++deadLasers;
	LD	A,(_deadLasers)
	INC	A
	LD	(_deadLasers),A
;  565	
;  566	                        } else if(laserLifetime[i] < 50) {
	JR	L_172
L_169:
	LD	HL,(IX+-21)
	LD	HL,(HL)
	LD	BC,50
	OR	A,A
	SBC	HL,BC
	JR	NC,L_167
;  567	
;  568	                            gfx_TransparentSprite(firing_tiles[laserAnimate[i]/3], 5, laserY[i]-11);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserAnimate
	ADD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,3
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LEA	BC,IY+-11
	PUSH	BC
	LD	BC,_firing_tiles_data
	ADD	HL,BC
	LD	BC,5
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  569	                            gfx_TransparentSprite(firing_tiles_flipped[laserAnimate[i]/3], 285, laserY[i]-11);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserAnimate
	ADD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,3
	CALL	__idivs
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LEA	BC,IY+-11
	PUSH	BC
	LD	BC,_firing_tiles_flipped
	ADD	HL,BC
	LD	BC,285
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  570	
;  571	                            for (i_the_sequel = 0; i_the_sequel < 10; ++i_the_sequel)
	XOR	A,A
	LD	(_i_the_sequel),A
	JR	L_163
L_161:
;  572	                            {
;  573	                                gfx_TransparentSprite(laser, 35 + (i_the_sequel * 25), laserY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_i_the_sequel)
	UEXT	HL
	LD	L,A
	LD	A,25
	CALL	__imul_b
	LD	IY,HL
	LEA	BC,IY+35
	PUSH	BC
	LD	BC,_laser_data
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
	LD	A,(_i_the_sequel)
	INC	A
	LD	(_i_the_sequel),A
;  574	                            }
L_163:
	LD	A,(_i_the_sequel)
	CP	A,10
	JR	C,L_161
	JR	L_172
;  575	
;  576	                        } else if (laserLifetime[i] < 100) {
L_167:
	LD	HL,(IX+-21)
	LD	HL,(HL)
	LD	BC,100
	OR	A,A
	SBC	HL,BC
	JR	NC,L_172
;  577	
;  578	                            //the simplest drawing code in this hot mess:
;  579	                            gfx_SetColor(3);
	LD	BC,3
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  580	
;  581	                            gfx_Line(20, laserY[i]+7, 300, laserY[i]+7);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	(IX+-60),HL
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	IY,HL
	LEA	BC,IY+7
	LD	DE,BC
	PUSH	DE
	LD	DE,300
	PUSH	DE
	PUSH	BC
	LD	BC,20
	PUSH	BC
	CALL	_gfx_Line
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  582	
;  583	                            gfx_Circle(11, laserY[i]+7, 9 + ((laserLifetime[i]-50)/2));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_laserLifetime
	ADD	HL,BC
	LD	IY,(HL)
	LEA	HL,IY+-50
	LD	A,1
	CALL	__ishru_b
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LEA	BC,IY+9
	PUSH	BC
	LD	IY,HL
	LEA	BC,IY+7
	PUSH	BC
	LD	BC,11
	PUSH	BC
	CALL	_gfx_Circle
	POP	BC
	POP	BC
	POP	BC
;  584	                            gfx_Circle(11, laserY[i]+7, 8 + ((laserLifetime[i]-50)/2));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_laserLifetime
	ADD	HL,BC
	LD	IY,(HL)
	LEA	HL,IY+-50
	LD	A,1
	CALL	__ishru_b
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LEA	BC,IY+8
	PUSH	BC
	LD	IY,HL
	LEA	BC,IY+7
	PUSH	BC
	LD	BC,11
	PUSH	BC
	CALL	_gfx_Circle
	POP	BC
	POP	BC
	POP	BC
;  585	
;  586	                            gfx_Circle(308, laserY[i]+7, 9 + ((laserLifetime[i]-50)/2));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_laserLifetime
	ADD	HL,BC
	LD	IY,(HL)
	LEA	HL,IY+-50
	LD	A,1
	CALL	__ishru_b
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LEA	BC,IY+9
	PUSH	BC
	LD	IY,HL
	LEA	BC,IY+7
	PUSH	BC
	LD	BC,308
	PUSH	BC
	CALL	_gfx_Circle
	POP	BC
	POP	BC
	POP	BC
;  587	                            gfx_Circle(308, laserY[i]+7, 8 + ((laserLifetime[i]-50)/2));
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_laserLifetime
	ADD	HL,BC
	LD	IY,(HL)
	LEA	HL,IY+-50
	LD	A,1
	CALL	__ishru_b
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LEA	BC,IY+8
	PUSH	BC
	LD	IY,HL
	LEA	BC,IY+7
	PUSH	BC
	LD	BC,308
	PUSH	BC
	CALL	_gfx_Circle
	POP	BC
	POP	BC
	POP	BC
;  588	
;  589	                            gfx_TransparentSprite(powering_tiles[0], laserX-19, laserY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_laserX)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	IY,HL
	LEA	BC,IY+-19
	PUSH	BC
	LD	BC,(_powering_tiles_data)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  590	                            gfx_TransparentSprite(powering_tiles_flipped[0], 320 - laserX, laserY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_laserX)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,320
	OR	A,A
	SBC	HL,BC
	PUSH	HL
	LD	BC,(_powering_tiles_flipped)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  591	
;  592	                            //reset the laser animation to zero before moving to the firing bit:
;  593	                            if (laserLifetime[i] == 49) laserAnimate[i] = 0;
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_laserLifetime
	ADD	HL,BC
	LD	HL,(HL)
	OR	A,A
	LD	BC,49
	SBC	HL,BC
	JR	NZ,L_172
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserAnimate
	ADD	HL,BC
	LD	(HL),0
;  594	                        }
L_172:
;  595	
;  596	                        if (laserAnimate[i] < 8)
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserAnimate
	ADD	HL,BC
	LD	(IX+-18),HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	OR	A,A
	LD	BC,8
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_171
;  597	                        {
;  598	                            ++laserAnimate[i];
	LD	HL,(IX+-18)
	LD	A,(HL)
	INC	A
	LD	HL,(IX+-18)
	LD	(HL),A
;  599	                        } else {
	JR	L_173
L_171:
;  600	                            laserAnimate[i] = 0;
	LD	HL,(IX+-18)
	LD	(HL),0
;  601	                        }
L_173:
;  602	
;  603	                        //update the laser's timer:
;  604	                        --laserLifetime[i];
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_laserLifetime
	ADD	HL,BC
	LD	(IX+-63),HL
	LD	IY,(HL)
	LEA	BC,IY+-1
	LD	HL,(IX+-63)
	LD	(HL),BC
;  605	                    }
;  606	                }
L_178:
;  607	
;  608	                gfx_TransparentSprite(powering_tiles[(laserAnimate[i]/3)+1], laserX-19, laserY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_laserX)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	IY,HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserAnimate
	ADD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,3
	CALL	__idivs
	INC	HL
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_powering_tiles_data
	ADD	HL,BC
	LEA	BC,IY+-19
	PUSH	BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  609	                gfx_TransparentSprite(powering_tiles_flipped[(laserAnimate[i]/3)+1], 320 - laserX, laserY[i]);
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserY
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	PUSH	HL
	LD	A,(_laserX)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,HL
	LD	HL,320
	OR	A,A
	SBC	HL,BC
	PUSH	HL
	LD	A,(_i)
	UEXT	HL
	LD	L,A
	LD	BC,_laserAnimate
	ADD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,3
	CALL	__idivs
	INC	HL
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_powering_tiles_flipped
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_TransparentSprite
	POP	BC
	POP	BC
	POP	BC
;  610	            }
;  611	        }
L_181:
	LD	A,(_i)
	INC	A
	LD	(_i),A
L_182:
	LD	A,(_i)
	CP	A,1
	JR	C,L_180
;  612	
;  613	        //FPS counter:
;  614	        frameTime = (32768 / timer_1_Counter);
	LD	HL,32768
	LD	E,0
	LD	BC,(15859712)
	LD	A,(15859715)
	CALL	__ldivu
	LD	BC,HL
	LD	A,C
	LD	(_frameTime),A
;  615	
;  616	        if (frameTime > 25)
	LD	A,25
	LD	HL,_frameTime
	CP	A,(HL)
	JR	NC,L_186
;  617	        {
;  618	            delay(40 - (1000/frameTime));
	LD	A,(_frameTime)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	HL,1000
	CALL	__idivs
	LD	BC,HL
	LD.LIS	HL,40
	OR	A,A
	SBC.SIS	HL,BC
	PUSH	HL
	CALL	_delay
	POP	BC
;  619	        }
L_186:
;  620	
;  621	        timer_1_Counter = 0;
;  622	
;  623	        gfx_SetTextScale(1, 1);
	LD	BC,1
	PUSH	BC
	PUSH	BC
	LD	BC,0
	LD	(15859712),BC
	XOR	A,A
	LD	(15859715),A
	CALL	_gfx_SetTextScale
	POP	BC
	POP	BC
;  624	        gfx_SetTextXY(280, 10);
	LD	BC,10
	PUSH	BC
	LD	BC,280
	PUSH	BC
	CALL	_gfx_SetTextXY
	POP	BC
	POP	BC
;  625	        gfx_PrintInt(frameTime, 2);
	LD	A,(_frameTime)
	UEXT	HL
	LD	BC,2
	PUSH	BC
	LD	L,A
	PUSH	HL
	LD	(IX+-82),A
	CALL	_gfx_PrintInt
	LD	A,(IX+-82)
	POP	BC
	POP	BC
;  626	
;  627	        gfx_SetTextXY(10, 30);
	LD	BC,30
	PUSH	BC
	LD	BC,10
	PUSH	BC
	LD	(IX+-82),A
	CALL	_gfx_SetTextXY
	LD	A,(IX+-82)
	POP	BC
	POP	BC
;  628	        gfx_PrintInt(monies, 4);
	LD	BC,4
	PUSH	BC
	LD	BC,(_monies)
	PUSH	BC
	LD	(IX+-82),A
	CALL	_gfx_PrintInt
	LD	A,(IX+-82)
	POP	BC
	POP	BC
;  629	
;  630	        gfx_SetTextScale(2,2);
	LD	BC,2
	PUSH	BC
	PUSH	BC
	LD	(IX+-82),A
	CALL	_gfx_SetTextScale
	LD	A,(IX+-82)
	POP	BC
	POP	BC
;  631	        gfx_SetTextXY(10, 10);
	LD	BC,10
	PUSH	BC
	PUSH	BC
	LD	(IX+-82),A
	CALL	_gfx_SetTextXY
	LD	A,(IX+-82)
	POP	BC
	POP	BC
;  632	        gfx_PrintInt((distance += scrollSpeed)/15, 4);
	UEXT	HL
	LD	A,(_scrollSpeed)
	LD	L,A
	LD	A,(_distance+3)
	LD	E,A
	LD	BC,HL
	LD	A,H
	LD	HL,(_distance)
	CALL	__ladd
	LD	(_distance),HL
	LD	A,E
	LD	(_distance+3),A
	LD	E,A
	XOR	A,A
	LD	BC,15
	LD	(IX+-78),HL	; spill
	LD	HL,4
	LD	(IX+-81),HL	; spill
	LD	HL,(IX+-78)	; unspill
	LD	(IX+-78),HL	; spill
	LD	HL,(IX+-81)	; unspill
	PUSH	HL
	LD	HL,(IX+-78)	; unspill
	CALL	__ldivu
	PUSH	HL
	CALL	_gfx_PrintInt
	POP	BC
	POP	BC
;  633	
;  634	        //gfx_BlitBuffer();
;  635	        gfx_SwapDraw();
	CALL	_gfx_SwapDraw
;  636	
;  637	    } while (!(kb_Data[6] & kb_Clear) && (health > 0));
	LD	A,(16056348)
	AND	A,64
	JR	NZ,L_198
	XOR	A,A
	LD	HL,_health
	CP	A,(HL)
	JP	M,L_188
L_198:
;  638	
;  639	    if (health < 1)
	LD	A,(_health)
	CP	A,1
	CALL	__setflag
	JP	P,L_199
;  640	    {
;  641	        gfx_FillScreen(1);
	LD	BC,1
	PUSH	BC
	CALL	_gfx_FillScreen
	POP	BC
;  642	        gfx_SetTextScale(4, 4);
	LD	BC,4
	PUSH	BC
	PUSH	BC
	CALL	_gfx_SetTextScale
	POP	BC
	POP	BC
;  643	        gfx_PrintStringXY("U is ded lol.", 15, 100);
	LD	BC,100
	PUSH	BC
	LD	BC,15
	PUSH	BC
	LD	BC,L__91
	PUSH	BC
	CALL	_gfx_PrintStringXY
	POP	BC
	POP	BC
	POP	BC
;  644	        gfx_SwapDraw();
	CALL	_gfx_SwapDraw
;  645	
;  646	        while (kb_AnyKey());
L_191:
	CALL	_kb_AnyKey
	OR	A,A
	JR	NZ,L_191
;  647	        while (!kb_AnyKey());
L_193:
	CALL	_kb_AnyKey
	OR	A,A
	JR	Z,L_193
;  648	
;  649	        if (kb_Data[6] != kb_Clear)
	LD	A,(16056348)
	CP	A,64
	JR	NZ,L_36
;  650	        {
;  651	            goto GAMESTART;
;  652	        }
;  653	    }
L_199:
;  654	
;  655	    //erase the decompressed sprites, very important:
;  656	    free(appvar_1);
	LD	BC,(_appvar_1)
	PUSH	BC
	CALL	_free
	POP	BC
;  657	    free(appvar_2);
	LD	BC,(_appvar_2)
	PUSH	BC
	CALL	_free
	POP	BC
;  658	
;  659	    //stop libraries, not doing so causes "interesting" results
;  660	    gfx_End();
	CALL	_gfx_End
;  661	
;  662	    ti_CloseAll();
	CALL	_ti_CloseAll
;  663	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_ti_CloseAll                        IMPORT  -----   function
;_gfx_End                            IMPORT  -----   function
;_appvar_2                           STATIC      3   variable
;_appvar_1                           STATIC      3   variable
;_free                               IMPORT  -----   function
;_kb_AnyKey                          IMPORT  -----   function
;_gfx_PrintStringXY                  IMPORT  -----   function
;_gfx_FillScreen                     IMPORT  -----   function
;_gfx_SwapDraw                       IMPORT  -----   function
;_gfx_PrintInt                       IMPORT  -----   function
;_gfx_SetTextXY                      IMPORT  -----   function
;_gfx_SetTextScale                   IMPORT  -----   function
;_delay                              IMPORT  -----   function
;_frameTime                          STATIC      1   variable
;_gfx_Circle                         IMPORT  -----   function
;_gfx_Line                           IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_laser_data                         IMPORT    377   variable
;_laserAnimate                       STATIC      1   variable
;_MAvalue                            STATIC      1   variable
;_missileWarning_tiles_data          IMPORT      9   variable
;_missileAnimate                     STATIC      1   variable
;_missileIncoming_tiles_data         IMPORT      6   variable
;_missile_data                       IMPORT   1658   variable
;_zapperAnimate                      STATIC      3   variable
;_randVar1                           STATIC      1   variable
;_beam_data                          IMPORT    102   variable
;_i_the_sequel                       STATIC      1   variable
;_abbreviatedMax                     IMPORT      6   variable
;_coin_tiles_data                    IMPORT     12   variable
;_sparkle_data                       IMPORT    242   variable
;_gfx_TransparentSprite              IMPORT  -----   function
;_nozzle_data                        IMPORT     16   variable
;_exhaust_tiles_data                 IMPORT     18   variable
;_avatar_tiles_data                  IMPORT     12   variable
;_abs                                IMPORT  -----   function
;_gfx_TransparentSprite_NoClip       IMPORT  -----   function
;_background_data                    IMPORT  46082   variable
;_gfx_Sprite                         IMPORT  -----   function
;_avatarAnimate                      STATIC      1   variable
;_displacement                       STATIC      1   variable
;_zapperY                            STATIC      9   variable
;_zapperLength                       STATIC      3   variable
;_zapperX                            STATIC      6   variable
;_laserX                             STATIC      1   variable
;_laserLifetime                      STATIC      3   variable
;_laserY                             STATIC      1   variable
;_missileY                           STATIC      1   variable
;_missileX                           STATIC      2   variable
;_coinAnimate                        STATIC     30   variable
;_coinY                              STATIC     30   variable
;_cty                                IMPORT    180   variable
;_coinX                              STATIC     90   variable
;_ctx                                IMPORT    540   variable
;_coinFormation                      STATIC      1   variable
;_randVar                            STATIC      1   variable
;_randObject                         STATIC      1   variable
;_random                             IMPORT  -----   function
;_backgroundScroll                   STATIC      3   variable
;_kb_Scan                            IMPORT  -----   function
;_deadLasers                         STATIC      1   variable
;_monies                             STATIC      4   variable
;_distance                           STATIC      4   variable
;_spawnDelay                         STATIC      3   variable
;_health                             STATIC      1   variable
;_flightTime                         STATIC      1   variable
;_holdTime                           STATIC      1   variable
;_avatarY                            STATIC      1   variable
;_avatarX                            STATIC      2   variable
;_scrollSpeed                        STATIC      1   variable
;_gfx_SetTextFGColor                 IMPORT  -----   function
;_gfx_SetTransparentColor            IMPORT  -----   function
;_jetpack_palette                    IMPORT    512   variable
;_gfx_SetPalette                     IMPORT  -----   function
;_gfx_SetDraw                        IMPORT  -----   function
;_gfx_Begin                          IMPORT  -----   function
;_shutdown_tiles_flipped             STATIC      9   variable
;_firing_tiles_data                  IMPORT      9   variable
;_firing_tiles_flipped               STATIC      9   variable
;_powering_tiles_data                IMPORT     12   variable
;_powering_tiles_flipped             STATIC     12   variable
;_gfx_RotateSpriteHalf               IMPORT  -----   function
;_gfx_FlipSpriteY                    IMPORT  -----   function
;_electric_tiles_data                IMPORT      6   variable
;_electric_animation                 STATIC     24   variable
;_zapper_tiles_data                  IMPORT      9   variable
;_gfx_FlipSpriteX                    IMPORT  -----   function
;_zapper_tiles_flipped               STATIC      9   variable
;_malloc                             IMPORT  -----   function
;_gfx_AllocSprite                    IMPORT  -----   function
;_i                                  STATIC      1   variable
;G_0                                  IX-48      3   variable
;G_2                                  IX-45      3   variable
;G_1                                  IX-42      3   variable
;G_19                                 IX-39      3   variable
;G_18                                 IX-36      3   variable
;G_9                                  IX-33      3   variable
;G_15                                 IX-30      3   variable
;G_14                                 IX-27      3   variable
;G_6                                  IX-24      3   variable
;G_25                                 IX-21      3   variable
;G_27                                 IX-18      3   variable
;G_12                                 IX-15      3   variable
;G_10                                 IX-12      3   variable
;G_16                                  IX-9      3   variable
;G_22                                  IX-6      3   variable
;G_3                                   IX-3      3   variable


; Stack Frame Size: 88 (bytes)
;       Spill Code: -1 (instruction)


	SEGMENT STRSECT
L__91:
	DB	"U is ded lol."
	DB	0
	XREF _powering_tiles_data:ROM
	XREF _firing_tiles_data:ROM
	XREF _missileIncoming_tiles_data:ROM
	XREF _missileWarning_tiles_data:ROM
	XREF _electric_tiles_data:ROM
	XREF _zapper_tiles_data:ROM
	XREF _coin_tiles_data:ROM
	XREF _exhaust_tiles_data:ROM
	XREF _avatar_tiles_data:ROM
	XREF _missile_data:ROM
	XREF _laser_data:ROM
	XREF _beam_data:ROM
	XREF _sparkle_data:ROM
	XREF _nozzle_data:ROM
	XREF _background_data:ROM
	XREF _jetpack_palette:ROM
	XREF _kb_AnyKey:ROM
	XREF _kb_Scan:ROM
	XREF _gfx_RotateSpriteHalf:ROM
	XREF _gfx_FlipSpriteY:ROM
	XREF _gfx_FlipSpriteX:ROM
	XREF _gfx_TransparentSprite_NoClip:ROM
	XREF _gfx_TransparentSprite:ROM
	XREF _gfx_Sprite:ROM
	XREF _gfx_SetTextFGColor:ROM
	XREF _gfx_SetTextXY:ROM
	XREF _gfx_PrintStringXY:ROM
	XREF _gfx_PrintInt:ROM
	XREF _gfx_SetTextScale:ROM
	XREF _gfx_SwapDraw:ROM
	XREF _gfx_SetDraw:ROM
	XREF _gfx_Circle:ROM
	XREF _gfx_Line:ROM
	XREF _gfx_FillScreen:ROM
	XREF _gfx_SetPalette:ROM
	XREF _gfx_SetTransparentColor:ROM
	XREF _gfx_SetColor:ROM
	XREF _gfx_End:ROM
	XREF _gfx_Begin:ROM
	XREF _gfx_AllocSprite:ROM
	XREF _ti_CloseAll:ROM
	XREF _abs:ROM
	XREF _free:ROM
	XREF _malloc:ROM
	XREF _delay:ROM
	XREF _random:ROM
	XREF __ladd:ROM
	XREF __idivs:ROM
	XREF __ldivu:ROM
	XREF __iremu:ROM
	XREF __stoiu:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __imul_b:ROM
	XREF __ladd_b:ROM
	XREF __ishru_b:ROM
	XDEF _main
	XDEF _delObjects
	XDEF _appvar_2
	XDEF _appvar_1
	XDEF _shutdown_tiles_flipped
	XDEF _firing_tiles_flipped
	XDEF _powering_tiles_flipped
	XDEF _electric_animation
	XDEF _zapper_tiles_flipped
	XDEF _deadLasers
	XDEF _laserAnimate
	XDEF _laserLifetime
	XDEF _laserY
	XDEF _laserX
	XDEF _MAvalue
	XDEF _missileAnimate
	XDEF _missileY
	XDEF _missileX
	XDEF _zapperAnimate
	XDEF _zapperLength
	XDEF _zapperX
	XDEF _zapperY
	XDEF _coinAnimate
	XDEF _coinFormation
	XDEF _coinY
	XDEF _coinX
	XDEF _randObject
	XDEF _randVar1
	XDEF _randVar
	XDEF _distance
	XDEF _monies
	XDEF _health
	XDEF _backgroundScroll
	XDEF _spawnDelay
	XDEF _scrollSpeed
	XDEF _holdTime
	XDEF _frameTime
	XDEF _flightTime
	XDEF _displacement
	XDEF _avatarAnimate
	XDEF _avatarY
	XDEF _avatarX
	XDEF _i_the_sequel
	XDEF _i
	XDEF _cty
	XDEF _ctx
	XDEF _abbreviatedMax
	END
